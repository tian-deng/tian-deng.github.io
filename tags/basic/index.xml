<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Basic on Rabbit Hole</title><link>https://example.com/tags/basic/</link><description>Recent content in Basic on Rabbit Hole</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 26 Sep 2020 21:34:18 +0800</lastBuildDate><atom:link href="https://example.com/tags/basic/index.xml" rel="self" type="application/rss+xml"/><item><title>Git操作指北</title><link>https://example.com/posts/tools/git/basic_git/</link><pubDate>Sat, 26 Sep 2020 21:34:18 +0800</pubDate><guid>https://example.com/posts/tools/git/basic_git/</guid><description>TODO: 对本版博文不是很满意, 后续重新更新~
建立仓库 我跟同学A想合作写一个小工具库，然后选了了 Git 作为版本控制系统, Github 作为托管服务器.
第一步首先是建立一个 Git 仓库, 哦不对, 是先下载 Git 工具, Git 是全平台的工具, 基本所有操作系统都支持. 我们直接百度找到官网从里面下载就可以了.
然后建立 Git 仓库, 我们怎么建立仓库呢? 有两种方法, 一种是在Github上创建一个新仓库.
登录Github后, 它长这样, 点击左边那个New来创建一个新的仓库.
如果想让 Github 帮我们初始化仓库, 那么就选择Add a README file选项. README file一般是对当前仓库所做的事情的一个简介. 相当于使用说明书.
让Github帮我们初始化, 就相当于运行了如下命令:
git init git add README.md git commit -m &amp;#34;Initial commit&amp;#34; git remote add origin git@github.com:tian-deng/Cooperation.git //先不管这行 这样就算完成了. 还有一种方法就是在本地用git init命令创建, 然后回头push到Github托管服务器上就ok.
我们要合作写项目, 那肯定要上传点东西到Github服务器, 服务器不能随便让别人直接上传到我们的项目对吧?服务器一般用的都是SSH协议来验证用户的, 所以需要先添加SSH key, 打开cmd, 在本地用ssh-keygen命令来创建公钥和密钥.一路回车就行</description></item><item><title>优雅的Rust</title><link>https://example.com/posts/rust/elegent_rust/</link><pubDate>Tue, 15 Sep 2020 15:30:44 +0800</pubDate><guid>https://example.com/posts/rust/elegent_rust/</guid><description>小记自己为什么会学 Rust . Rust 有什么特性吸引到我了~
如果说 C 语言是具备高灵活性, 信任着开发者, 将一切交给开发者来解决的话.
那么 Rust 就是降低该灵活性, 毫不信任开发者, 将开发者的大部分错误都在编译期发掘出来, 强制要求开发者去了解可能存在的问题并解决掉它.
C 语言可能条条大路通罗马, Rust 可能只有寥寥无几的道路.
总之, Rust 拔高了开发者的下限, 如果水平不够是连编译器都不会通过的, 更不要说 commit 了.
优雅的Rust 听说到 Rust 最多的自然是所谓的内存安全. 那么什么是内存安全？ 内存安全体现在哪里呢？
比如说这段 C语言 代码.
int a[5]; a[6] = 6; printf(&amp;#34;%d&amp;#34;, a[6]); 这段代码能正确输出 a[6] 吗?
答案是可以的, 虽然它很明显的内存越界了, 但内存越界似乎在 C 里并不是什么大不了的事, 编写的代码随便越界, 只不过导致的后果需要自己承担而已.
当然现今大部分的高级语言对指针越界都会有很明确的编译错误, 所以仅这点来看并不能体现出 Rust 的特点, 只不过是有了现代语言该有的东西——内存越界提示.
那么有什么可以体现出 Rust 独有特性的地方呢?
参考这一段结构体.
typedef struct { struct Node *next; int val; }Node; typedef struct { Node *head; Node *tail; int size; }LinkedList; struct { void (*push)(struct LinkedList *self, Node val); Node *(*peek)(struct LinkedList *self); Node *(*pop)(struct LinkedList *self); }StackMethod; 这是一个简单的数据结构栈, 在栈方法中定义了三个函数指针, 不需要关注 push 方法, 来看看 peek 方法.</description></item></channel></rss>