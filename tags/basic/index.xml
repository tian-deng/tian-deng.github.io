<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Basic on Rabbit Hole</title><link>https://example.com/tags/basic/</link><description>Recent content in Basic on Rabbit Hole</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 26 Sep 2020 21:34:18 +0800</lastBuildDate><atom:link href="https://example.com/tags/basic/index.xml" rel="self" type="application/rss+xml"/><item><title>Git操作指北</title><link>https://example.com/posts/tools/git/basic_git/</link><pubDate>Sat, 26 Sep 2020 21:34:18 +0800</pubDate><guid>https://example.com/posts/tools/git/basic_git/</guid><description> TODO: 对本版博文不是很满意, 后续重新更新~
重写入门部分.
增加常用命令相关部分.
&amp;hellip;</description></item><item><title>优雅的Rust</title><link>https://example.com/posts/rust/elegent_rust/</link><pubDate>Tue, 15 Sep 2020 15:30:44 +0800</pubDate><guid>https://example.com/posts/rust/elegent_rust/</guid><description>小记自己为什么会学 Rust . Rust 有什么特性吸引到我了~
如果说 C 语言是具备高灵活性, 信任着开发者, 将一切交给开发者来解决的话.
那么 Rust 就是降低该灵活性, 毫不信任开发者, 将开发者的大部分错误都在编译期发掘出来, 强制要求开发者去了解可能存在的问题并解决掉它.
C 语言可能条条大路通罗马, Rust 可能只有寥寥无几的道路.
总之, Rust 拔高了开发者的下限, 如果水平不够是连编译器都不会通过的, 更不要说 commit 了.
优雅的Rust 听说到 Rust 最多的自然是所谓的内存安全. 那么什么是内存安全？ 内存安全体现在哪里呢？
比如说这段 C语言 代码.
int a[5]; a[6] = 6; printf(&amp;#34;%d&amp;#34;, a[6]); 这段代码能正确输出 a[6] 吗?
答案是可以的, 虽然它很明显的内存越界了, 但内存越界似乎在 C 里并不是什么大不了的事, 编写的代码随便越界, 只不过导致的后果需要自己承担而已.
当然现今大部分的高级语言对指针越界都会有很明确的编译错误, 所以仅这点来看并不能体现出 Rust 的特点, 只不过是有了现代语言该有的东西——内存越界提示.
那么有什么可以体现出 Rust 独有特性的地方呢?
参考这一段结构体.
typedef struct { struct Node *next; int val; }Node; typedef struct { Node *head; Node *tail; int size; }LinkedList; struct { void (*push)(struct LinkedList *self, Node val); Node *(*peek)(struct LinkedList *self); Node *(*pop)(struct LinkedList *self); }StackMethod; 这是一个简单的数据结构栈, 在栈方法中定义了三个函数指针, 不需要关注 push 方法, 来看看 peek 方法.</description></item></channel></rss>