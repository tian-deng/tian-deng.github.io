<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Concept on Rabbit Hole</title><link>https://example.com/tags/concept/</link><description>Recent content in Concept on Rabbit Hole</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 18 Nov 2020 13:28:44 +0800</lastBuildDate><atom:link href="https://example.com/tags/concept/index.xml" rel="self" type="application/rss+xml"/><item><title>逆变与协变</title><link>https://example.com/posts/programminglanguage/covariance_and_contravariance/</link><pubDate>Wed, 18 Nov 2020 13:28:44 +0800</pubDate><guid>https://example.com/posts/programminglanguage/covariance_and_contravariance/</guid><description>逆变和协变看了忘忘了看, 这次学C#顺带查阅各处总结了下&amp;hellip;
协变
协变是指能够使用比原始指定的类型派生程度更大的类型.
例如Dog与Cat继承自Animal, 那么从Dog-&amp;gt;Animal就称为协变, 那么协变有什么作用呢?
// Animal.cs public abstract class Animal { } public class Dog : Animal { } // Main.cs public static void Main() { Dog dog = new Dog(); Animal animal = dog; List&amp;lt;Dog&amp;gt; dogs = new List&amp;lt;Dog&amp;gt;(); List&amp;lt;Animal&amp;gt; animals = dogs; // error } Dog继承自Animal, 所以Dog可以隐式的转化为Animal, 但是List与List之间没有继承关系, 所以无法隐式转换, 如果想要隐式转换需要如下代码:
List&amp;lt;Animal&amp;gt; animals = dogs.Select(d =&amp;gt; (Animal)d).ToList(); 将小狗列表中的小狗挨个显式转换为Animal.
所以C#提供了协变的语法糖, 也就是out, 意思是指该泛型可以作为输出返回. 也就是说可以用如下代码:
// Main.cs public static void Main() { Dog dog = new Dog(); Animal animal = dog; IEnumerable&amp;lt;Dog&amp;gt; dogs = new List&amp;lt;Dog&amp;gt;(); IEnumerable&amp;lt;Animal&amp;gt; animals = dogs; } // IEnumerable public interface IEnumerable&amp;lt;out T&amp;gt;: IEnumerable 因为T只能作为结果返回, 所以T不会被修改, 编译器可以帮我们进行强制转换.</description></item></channel></rss>