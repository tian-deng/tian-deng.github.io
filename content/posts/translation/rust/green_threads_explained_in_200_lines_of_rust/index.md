---
title: 200行Rust代码解释绿色线程
date: 2020-11-18T13:28:44+08:00
lastmod: 2020-11-20T00:41:00+08:00
draft: true
slug: green_threads_explained_in_200_lines_of_rust
image: cover.png
categories:
    - Rust
tags:
    - Translation
    - Rust
    - Async
---

>  本译文译自 [Green Threads Explained in 200 Lines of Rust](https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/)

---



# 介绍

这本书目标是通过我们自己编写实现的一个简单可用的绿色线程代码, 来解释绿色线程.

> 所有代码可以在该 [Git仓库](https://github.com/cfsamson/example-greenthreads) 找到, 它有两个分支, `main` 分支仅仅包括代码, `commented` 分支包含解释我们做了什么的注释.

绿色线程, 用户态线程, 协程(goroutines), 纤程(fibers), 它们有多种称谓, 但是简单起见我将会在后续统一称之为绿色线程.

在这篇文章中我将通过实现一个200行 `Rust` 绿色线程代码的简单例子来解释它是如何工作的.

> 我们不会使用任何的外部库来确保我们真正的理解发生了什么.



## 谁适合阅读这篇文章

我们深陷在一个兔子坑中, 如果它听起来很可怕, 那么这篇文章可能不适合你, 像曾经一样去做点轻松愉悦的事情吧~

如果你还是很好奇事情是如何工作的, 那么继续读下去. 你可能听说过 `Go` 的 `goroutines`, 或者 `Ruby` 和 `Julia` 中等价的那些, 你可能知道它们怎么使用但是又想知道它们是如何工作的, 请继续读下去.

 另外, 如果你是以下这类人的话那也可能比较有趣:

* 你是 `Rust` 初学者并且想学习更多的特性.
* 你已经在 `Rust社区` 中了解讨论过 `async/await`, `Pin`, 和为什么需要生成器. 我们将试着把那些都整合在这篇文章中.
* 或许你想了解 `Rust` 内联汇编的基础知识.
* 或许你只是单纯的感兴趣.

Well, 现在加入我们并且试着了解我们需要了解的一切~

你不需要是一个 `Rust` 程序员就可以理解本文, 但是我们强烈建议你首先能够知道一些简单的语法, 如果你想亲手尝试编写代码玩玩那么你可能需要获取 `Rust` 并且学习些基础知识.

## 顺便

所有代码都在一个单文件中并且没有额外的依赖, 这意味着你可以简单的开始你的项目来自己亲自尝试, 你也可以在 [Rust playground](https://play.rust-lang.org/) 中运行代码, 但是记住我们的代码是依赖于 `nightly` 的部分特性, 所以你需要先将编译器切换到 `nightly` 版本.



# 绿色线程

绿色线程解决了编程中的一个通用问题. 你不希望你的代码阻塞 `CPU` 来阻止 `CPU` 去做一些有意义的工作. 我们通过多任务来解决这个问题, 这使得我们可以挂起运行中的一块代码去执行另一块代码, 并且在上下文之间切换.

虽然很容易把它和并行混淆但是它们是两回事. 想象一下, 绿色线程让我们使用现有的资源更加聪明高效的工作, 而并行则是在问题上投入了更多的资源.

通常有两种途径来做到这一点:

* 抢占式多任务
* 非抢占式多任务

## 抢占式多任务

某些外部调度器会停止一个任务并在切换回来之前去执行另一个任务. 在这种情形下任务与之无关, 决策取决于其它的东西(通常是某些调度程序). 内核在操作系统中使用这种方式, 举例来说, 这允许你在单线程系统中使用 `UI` 的同时来让 `CPU` 去做一些计算. 我们现在不会在本文中讨论这种线程, 但是我想当你理解了一个范例, 你能够对这两个范例都有很好的掌握.

## 非抢占式多任务

这是我们今天所要讲的. 一个任务自己去决定让 `CPU` 去做一些其他事情比起让它等待当前线程发生些什么. 通常通过 `yielding/让出` 控制权给调度器来完成的. 一般是在阻塞事情发生的时候让出执行权. 一个简单的例子是 `IO操作`. 当控制权让出后一个中心调度器指示 `CPU` 继续其它已经准备好的任务的工作而不是就在那里停滞着.



# 背景知识

这部分是本书中最具有技术性的部分, 但是如果我们真的想要理解绿色线程的话就不得不去了解它们, 我保证我会尽可能快地说到点子上来让我们足以开始编写代码.

Here we go! 首先, 我们将直接干预控制 `CPU`. 这并不是特别好移植的因为现实有很多种 `CPU`, 主要思路是一样的, 一些实现细节可能会有些许不同.

我们在本文中会覆盖到的是使用地更加通用的架构: `x86-64`

在这个架构中 `CPU` 的特点是有一组16个寄存器.

![register_usage](./register_usage.png)

如果你对图片的其余部分有兴趣的话你可以在 [这里](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI) 找到它.

我们感兴趣的是那些被标记为 `callee saved` 的寄存器.

> 译者: callee-saved 又称作非易失性/被调用者保存寄存器, 当调用者进行过程调用时, 可以期望这些寄存器在被调用者返回后将保持相同的值, 这使被调用者有责任在返回调用者之前保存它们并恢复它们.

这些寄存器用于记录我们的上下文: 下一个要运行的指令, 基指针, 栈指针...... 我们将会在后面了解更多的细节.

如果我们想要直接指示 `CPU` 我们需要编写一小部分汇编代码, 幸运的是在我们的关卡中我们只需要了解一小部分汇编指令. 比如怎么S从寄存器中移动值:

```assembly
mov %rsp, %rax
```

> `Windows` 系有些不同的习惯. 在 `Windows` 系统上 `XMM6:XMM15` 也是 `callee-saved` 寄存器, 如果我们在函数中使用了它们也必须保存和恢复它们. 我们如果在例子中只用 `psABI` 的话, 那么代码在 `Windows` 上也能很好的运行.

## 超级快的汇编介绍

首先并且也是最重要的, 汇编语言通常并不是很便携, 每个 `CPU` 都可能有自己特别的指令, 然而有些指令在当今的桌面电脑上是通用的.

`AT&T` 方言是编写 `Rust` 内联汇编的标准语言, 但是如果我们想的话我们也可以在 `Rust` 中使用 `Intel` 方言. `Rust` 主要把内联汇编留给 `LLVM` 处理, `LLVM` 的内联汇编在语法上非常接近我们在 `C` 中编写的内联汇编. 这就可以让我们可以通过 `C inline ASM` 来学习(但并不完全相同).

我们将会在我们的例子中使用 `AT&T` 方言.

汇编有着非常强的向后兼容性保证. 这也是为什么你可能会看到用不同的方法来寻址相同的寄存器. 让我们看看 `%rax` 寄存器来解释我们之前所说的.

``` assembly
%rax    # 64 bit register (8 bytes)
%eax    # 32 low bits of the "rax" register
%ax     # 16 low bits of the "rax" register
%ah     # 8 high bits of the "ax" part of the "rax" register
%al     # 8 low bits of the "ax" part of the "rax" register
```

就像你看到的那样, 这就像是看到了 `CPU` 的发展历史~从8位到16位到32再到如今的64位. 因为现今大部分 `CPU` 都是64位的, 所以我们将在我们的代码中使用 `64` 位寄存器.

`word/字` 的大小在汇编中有着历史原因, 它起源于 `CPU` 有16位数据总线的时候, 所以一个字是16位. 这与我们使用的 `AT&T` 方言是有关联性的, 因为我们后面将会使用一些以字作为后缀的命令, 比如: `q/quad-word`, `l/long-word`, 所以 `movq` 表示 4 * 16 = 64 bits.

`mov` 使用的大小取决于你使用的寄存器, 这是标准 `Intel` 方言并且也是我们接下来在代码中使用的标准.

我们将会在下一个章节中遨游更多的内联汇编的语法.

一个小贴士: 栈对齐在 `x86-64` 架构上是16位. 请在之后记住这一点~



# 一个建立于可编译基础上的例子

> 在这个例子中我们将创建自己的栈并且使我们的 `CPU` 从当前执行的上下文到我们刚刚创建的栈中. 我们将在接下来的文字中建立这些概念(但我们不会基于代码建立).

## 设置我们的项目

首先我们需要创建一个项目在文件夹 "green_threads" 中, 运行:

> cargo init

由于我们需要使用一些不稳定特性, 所以需要先切换到 `Nightly` 版编译器:

> rustup override set nightly

在我们的 `main.rs` 中我们设置一个特性标签来让我们可以使用 `llvm_asm!` 宏:

```rust
// main.rs:
#![feature(llvm_asm)]
```

让我们在这里设置一个48字节的栈大小以让我们在切换上下文之前可以打印看看它:

```rust
// main.rs:
const SSIZE: isize = 48;
```

> 在 `OSX` 系统上使用这么小的栈可能会有些问题, 最小的可运行栈大小是624字节. 如果你想原模原样的照抄, 这些代码是可以在 [Rust Playground](https://play.rust-lang.org/) 上运行的(但是由于我们后面编写的无限循环, 你可能需要等~30秒运行才能超时结束).

接下来让我们写一个结构体来表示我们的 `CPU` 状态. 我们现在所需要关注的仅仅是保存栈指针的寄存器:

```rust
// main.rs
#[derive(Debug, Default)]
#[repr(C)]
struct ThreadContext {
    rsp: u64,
}
```

在后面的例子中我将使用我上面链接文档中被标记为 `callee saved` 的所有寄存器. 那些是在 `x86-64 ABI` 中描述的寄存器, 我们需要使用它们来保存上下文, 但是现在我们只需要其中一个来让 `CPU` 跳转到我们的栈中.

注意 `#[repr(C)]`, 因为我们使用汇编的方式来访问我们的数据. `Rust` 没有一个稳定的 `ABI` 所以我们没有办法确保 `rsp` 在我们的内存中以前8个字节表示. `C` 有稳定的 `ABI`, 这个属性就是告诉编译器该结构体使用 `C` 的内存布局方式. 我们的结构体目前只有一个字段, 当然我们会在后面添加更多~

```rust
// main.rs
fn hello() -> ! {
    println!("I LOVE WAKING UP ON A NEW STACK!");
    loop{}
}
```

在这个简单的示例中我们仅仅是定义了一个打印一段话的函数, 然后无限循环.

下一步是我们用来切换到我们的栈的内联汇编.

```rust
unsafe fn gt_switch(new: *const ThreadContext) {
    llvm_asm!("
        mov 0x00($0), %rsp
        ret
        "
    :
    :   "r"(new)
    :
    :   "alignstack" // 不会在现在工作, 后面会用到.
    );
}
```

我们使用了一个小技巧. 我们在我们的新栈上写入我们想要运行的函数的地址, 然后我们把存储该地址第一个字节的地址传递给 `rsp` 寄存器(我们设置为 `new.rsp` 的地址将会指向我们栈的地址, 这个栈的地址指向上面的函数). 明白了吗?

`ret` 关键字将程序的控制权转给栈顶返回的地址. 因为我们把我们的地址 `pushed` 到 `%rsp` 寄存器中, `CPU` 将会认为这个地址是当前正在运行的函数返回的地址, 所以当我们使用 `ret` 指令时它将直接返回到我们自己的栈中(也就是new的地址).

然后 `CPU` 做的第一件事就是读取我们函数的地址并运行它.

## 快速介绍 `Rust` 的内联汇编宏

如果你以前没用过内联汇编你可能会觉得那些看上去像是火星文, 但是我们稍后会使用这个拓展版本来切换上下文, 所以现在我们将逐行解释我们做了什么.

`unsafe` 是一个关键字, 它让 `Rust` 不能强制确保我们编写的函数的安全性. 因为我们直接操作 `CPU`, 这绝对是不安全的.

```rust
fn gt_switch(new: *const ThreadContext)
```

在这里我们获取了一个指向 `ThreadContext` 实例的指针, 从中我们只读取了一个字段.

```rust
llvm_asm!()
```

这是 `Rust` 标准库中的 `llvm_asm!` 宏. 它会检查我们的汇编语法, 如果遇到一些看起来不像是 `AT&T` 方言的语法, 它将提供一个错误信息.

宏首先接收的参数是一个汇编模板:

```assembly
mov 0x00($0), %rsp
```

这是一个简单的指令, 它将存储在 `$0` 位置 的 `0x00(16进制表示, 这里表示不偏移)` 偏移量的值移动到 `rsp` 寄存器中. 因为 `rsp` 寄存器保存一个指向栈中下一个值的指针, 我们有效地将我们提供的地址 `push` 到当前的栈顶来覆盖原先存在的地址.

你可能认为 `$0` 看起来不是一个普通的汇编代码. 这是汇编模板的部分, 表示第一个参数的占位符. 这个参数从0, 1, 2...技术, 首先是 `output` 参数, 紧接着是 `input` 参数. 我们在这里只使用了对应于 `$0` 的输入参数.

如果在汇编中碰到 `$` 符号可能大部分时候表示一个立即数(常量整数)但是这是有依赖的(yeah, `$` 在不同的方言或者是不同的架构如 `x86` 与 `x86-64` 之间都表示不同的意义).

```assembly
ret
```
