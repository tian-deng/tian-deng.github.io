---
title: 200行Rust代码解释绿色线程
date: 2020-11-18T13:28:44+08:00
draft: true
slug: green_threads_explained_in_200_lines_of_rust
categories:
    - Rust
tags:
    - Translation
    - Rust
    - Async
---

>  本译文译自 [Green Threads Explained in 200 Lines of Rust](https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/)

---



# 介绍

这本书目标是通过我们自己编写实现的一个简单可用的绿色线程代码, 来解释绿色线程.

> 所有代码可以在该 [Git仓库](https://github.com/cfsamson/example-greenthreads) 找到, 它有两个分支, `main` 分支仅仅包括代码, `commented` 分支包含解释我们做了什么的注释.

绿色线程, 用户态线程, 协程(goroutines), 纤程(fibers), 它们有多种称谓, 但是简单起见我将会在后续统一称之为绿色线程.

在这篇文章中我将通过实现一个200行 `Rust` 绿色线程代码的简单例子来解释它是如何工作的.

> 我们不会使用任何的外部库来确保我们真正的理解发生了什么.
>
> 



## 谁适合阅读这篇文章

我们深陷在一个兔子坑中, 如果它听起来很可怕, 那么这篇文章可能不适合你, 像曾经一样去做点轻松愉悦的事情吧~

如果你还是很好奇事情是如何工作的, 那么继续读下去. 你可能听说过 `Go` 的 `goroutines`, 或者 `Ruby` 和 `Julia` 中等价的那些, 你可能知道它们怎么使用但是又想知道它们是如何工作的, 请继续读下去.

 另外, 如果你是以下这类人的话那也可能比较有趣:

* 你是 `Rust` 初学者并且想学习更多的特性.
* 你已经在 `Rust社区` 中了解讨论过 `async/await`, `Pin`, 和为什么需要生成器. 我们将试着把那些都整合在这篇文章中.
* 或许你想了解 `Rust` 内联汇编的基础知识.
* 或许你只是单纯的感兴趣.

Well, 现在加入我们并且试着了解我们需要了解的一切~

你不需要是一个 `Rust` 程序员就可以理解本文, 但是我们强烈建议你首先能够知道一些简单的语法, 如果你想亲手尝试编写代码玩玩那么你可能需要获取 `Rust` 并且学习些基础知识.

## 顺便

所有代码都在一个单文件中并且没有额外的依赖, 这意味着你可以简单的开始你的项目来自己亲自尝试, 你也可以在 [Rust playground](https://play.rust-lang.org/) 中运行代码, 但是记住我们的代码是依赖于 `nightly` 的部分特性, 所以你需要先将编译器切换到 `nightly` 版本.



# 绿色线程

绿色线程解决了编程中的一个通用问题. 你不希望你的代码阻塞 `CPU` 来阻止 `CPU` 去做一些有意义的工作. 我们通过多任务来解决这个问题, 这使得我们可以挂起运行中的一块代码去执行另一块代码, 并且在上下文之间切换.

虽然很容易把它和并行混淆但是它们是两回事. 想象一下, 绿色线程让我们使用现有的资源更加聪明高效的工作, 而并行则是在问题上投入了更多的资源.

通常有两种途径来做到这一点:

* 抢占式多任务
* 非抢占式多任务

## 抢占式多任务

某些外部调度器会停止一个任务并在切换回来之前去执行另一个任务. 在这种情形下任务与之无关, 决策取决于其它的东西(通常是某些调度程序). 内核在操作系统中使用这种方式, 举例来说, 这允许你在单线程系统中使用 `UI` 的同时来让 `CPU` 去做一些计算. 我们现在不会在本文中讨论这种线程, 但是我想当你理解了一个范例, 你能够对这两个范例都有很好的掌握.

## 非抢占式多任务

这是我们今天所要讲的. 一个任务自己去决定让 `CPU` 去做一些其他事情比起让它等待当前线程发生些什么. 通常通过 `yielding/让出` 控制权给调度器来完成的. 一般是在阻塞事情发生的时候让出执行权. 一个简单的例子是 `IO操作`. 当控制权让出后一个中心调度器指示 `CPU` 继续其它已经准备好的任务的工作而不是就在那里停滞着.



# 背景信息

这部分是本书中最具有技术性的部分, 但是如果我们真的想要理解绿色线程的话就不得不去了解它们, 我保证我会尽可能快地说到点子上来让我们足以开始编写代码.

Here we go! 首先, 我们将直接干预控制 `CPU`. 这并不是特别好移植的因为现实有很多种 `CPU`, 主要思路是一样的, 一些实现细节可能会有些许不同.

我们在本文中会覆盖到的是使用地更加通用的架构: `x86-64`

在这个架构中 `CPU` 的特点是有一组16个寄存器.

![register_usage](./register_usage.png)

如果你对图片的其余部分有兴趣的话你可以在 [这里](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI) 找到它.

我们感兴趣的是那些被标记为 `callee saved` 的寄存器.

> 译者: callee-saved 又称作非易失性/被调用者保存寄存器, 当调用者进行过程调用时, 可以期望这些寄存器在被调用者返回后将保持相同的值, 这使被调用者有责任在返回调用者之前保存它们并恢复它们.

这些寄存器用于记录我们的上下文: 下一个要运行的指令, 基指针, 栈指针...... 我们将会在后面了解更多的细节.

如果我们想要直接指示 `CPU` 我们需要编写一小部分汇编代码, 幸运的是在我们的关卡中我们只需要了解一小部分汇编指令. 如何从寄存器中移动值:

```assembly
mov %rsp, %rax
```