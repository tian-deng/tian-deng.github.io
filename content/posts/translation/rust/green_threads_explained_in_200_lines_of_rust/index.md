---
title: 200行Rust代码解释绿色线程
date: 2020-11-18T13:28:44+08:00
lastmod: 2020-11-19T22:02:00+08:00
draft: true
slug: green_threads_explained_in_200_lines_of_rust
categories:
    - Rust
tags:
    - Translation
    - Rust
    - Async
---

>  本译文译自 [Green Threads Explained in 200 Lines of Rust](https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/)

---



# 介绍

这本书目标是通过我们自己编写实现的一个简单可用的绿色线程代码, 来解释绿色线程.

> 所有代码可以在该 [Git仓库](https://github.com/cfsamson/example-greenthreads) 找到, 它有两个分支, `main` 分支仅仅包括代码, `commented` 分支包含解释我们做了什么的注释.

绿色线程, 用户态线程, 协程(goroutines), 纤程(fibers), 它们有多种称谓, 但是简单起见我将会在后续统一称之为绿色线程.

在这篇文章中我将通过实现一个200行 `Rust` 绿色线程代码的简单例子来解释它是如何工作的.

> 我们不会使用任何的外部库来确保我们真正的理解发生了什么.



## 谁适合阅读这篇文章

我们深陷在一个兔子坑中, 如果它听起来很可怕, 那么这篇文章可能不适合你, 像曾经一样去做点轻松愉悦的事情吧~

如果你还是很好奇事情是如何工作的, 那么继续读下去. 你可能听说过 `Go` 的 `goroutines`, 或者 `Ruby` 和 `Julia` 中等价的那些, 你可能知道它们怎么使用但是又想知道它们是如何工作的, 请继续读下去.

 另外, 如果你是以下这类人的话那也可能比较有趣:

* 你是 `Rust` 初学者并且想学习更多的特性.
* 你已经在 `Rust社区` 中了解讨论过 `async/await`, `Pin`, 和为什么需要生成器. 我们将试着把那些都整合在这篇文章中.
* 或许你想了解 `Rust` 内联汇编的基础知识.
* 或许你只是单纯的感兴趣.

Well, 现在加入我们并且试着了解我们需要了解的一切~

你不需要是一个 `Rust` 程序员就可以理解本文, 但是我们强烈建议你首先能够知道一些简单的语法, 如果你想亲手尝试编写代码玩玩那么你可能需要获取 `Rust` 并且学习些基础知识.

## 顺便

所有代码都在一个单文件中并且没有额外的依赖, 这意味着你可以简单的开始你的项目来自己亲自尝试, 你也可以在 [Rust playground](https://play.rust-lang.org/) 中运行代码, 但是记住我们的代码是依赖于 `nightly` 的部分特性, 所以你需要先将编译器切换到 `nightly` 版本.



# 绿色线程

绿色线程解决了编程中的一个通用问题. 你不希望你的代码阻塞 `CPU` 来阻止 `CPU` 去做一些有意义的工作. 我们通过多任务来解决这个问题, 这使得我们可以挂起运行中的一块代码去执行另一块代码, 并且在上下文之间切换.

虽然很容易把它和并行混淆但是它们是两回事. 想象一下, 绿色线程让我们使用现有的资源更加聪明高效的工作, 而并行则是在问题上投入了更多的资源.

通常有两种途径来做到这一点:

* 抢占式多任务
* 非抢占式多任务

## 抢占式多任务

某些外部调度器会停止一个任务并在切换回来之前去执行另一个任务. 在这种情形下任务与之无关, 决策取决于其它的东西(通常是某些调度程序). 内核在操作系统中使用这种方式, 举例来说, 这允许你在单线程系统中使用 `UI` 的同时来让 `CPU` 去做一些计算. 我们现在不会在本文中讨论这种线程, 但是我想当你理解了一个范例, 你能够对这两个范例都有很好的掌握.

## 非抢占式多任务

这是我们今天所要讲的. 一个任务自己去决定让 `CPU` 去做一些其他事情比起让它等待当前线程发生些什么. 通常通过 `yielding/让出` 控制权给调度器来完成的. 一般是在阻塞事情发生的时候让出执行权. 一个简单的例子是 `IO操作`. 当控制权让出后一个中心调度器指示 `CPU` 继续其它已经准备好的任务的工作而不是就在那里停滞着.



# 背景知识

这部分是本书中最具有技术性的部分, 但是如果我们真的想要理解绿色线程的话就不得不去了解它们, 我保证我会尽可能快地说到点子上来让我们足以开始编写代码.

Here we go! 首先, 我们将直接干预控制 `CPU`. 这并不是特别好移植的因为现实有很多种 `CPU`, 主要思路是一样的, 一些实现细节可能会有些许不同.

我们在本文中会覆盖到的是使用地更加通用的架构: `x86-64`

在这个架构中 `CPU` 的特点是有一组16个寄存器.

![register_usage](./register_usage.png)

如果你对图片的其余部分有兴趣的话你可以在 [这里](https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI) 找到它.

我们感兴趣的是那些被标记为 `callee saved` 的寄存器.

> 译者: callee-saved 又称作非易失性/被调用者保存寄存器, 当调用者进行过程调用时, 可以期望这些寄存器在被调用者返回后将保持相同的值, 这使被调用者有责任在返回调用者之前保存它们并恢复它们.

这些寄存器用于记录我们的上下文: 下一个要运行的指令, 基指针, 栈指针...... 我们将会在后面了解更多的细节.

如果我们想要直接指示 `CPU` 我们需要编写一小部分汇编代码, 幸运的是在我们的关卡中我们只需要了解一小部分汇编指令. 比如怎么S从寄存器中移动值:

```assembly
mov %rsp, %rax
```

> `Windows` 系有些不同的习惯. 在 `Windows` 系统上 `XMM6:XMM15` 也是 `callee-saved` 寄存器, 如果我们在函数中使用了它们也必须保存和恢复它们. 我们如果在例子中只用 `psABI` 的话, 那么代码在 `Windows` 上也能很好的运行.

## 超级快的汇编介绍

首先并且也是最重要的, 汇编语言通常并不是很便携, 每个 `CPU` 都可能有自己特别的指令, 然而有些指令在当今的桌面电脑上是通用的.

`AT&T` 方言是编写 `Rust` 内联汇编的标准语言, 但是如果我们想的话我们也可以在 `Rust` 中使用 `Intel` 方言. `Rust` 主要把内联汇编留给 `LLVM` 处理, `LLVM` 的内联汇编在语法上非常接近我们在 `C` 中编写的内联汇编. 这就可以让我们可以通过 `C inline ASM` 来学习(但并不完全相同).

我们将会在我们的例子中使用 `AT&T` 方言.

汇编有着非常强的向后兼容性保证. 这也是为什么你可能会看到用不同的方法来寻址相同的寄存器. 让我们看看 `%rax` 寄存器来解释我们之前所说的.

``` assembly
%rax    # 64 bit register (8 bytes)
%eax    # 32 low bits of the "rax" register
%ax     # 16 low bits of the "rax" register
%ah     # 8 high bits of the "ax" part of the "rax" register
%al     # 8 low bits of the "ax" part of the "rax" register
```

就像你看到的那样, 这就像是看到了 `CPU` 的发展历史~从8位到16位到32再到如今的64位. 因为现今大部分 `CPU` 都是64位的, 所以我们将在我们的代码中使用 `64` 位寄存器.

`word/字` 的大小在汇编中有着历史原因, 它起源于 `CPU` 有16位数据总线的时候, 所以一个字是16位. 这与我们使用的 `AT&T` 方言是有关联性的, 因为我们后面将会使用一些以字作为后缀的命令, 比如: `q/quad-word`, `l/long-word`, 所以 `movq` 表示 4 * 16 = 64 bits.

`mov` 使用的大小取决于你使用的寄存器, 这是标准 `Intel` 方言并且也是我们接下来在代码中使用的标准.

我们将会在下一个章节中遨游更多的内联汇编的语法.

一个小贴士: 栈对齐在 `x86-64` 架构上是16位. 请在之后记住这一点~



# 一个建立于可编译基础上的例子

> 在这个例子中我们将创建自己的栈并且使我们的 `CPU` 从当前执行的上下文到我们刚刚创建的栈中. 我们将在接下来的文字中建立这些概念(但我们不会基于代码建立).

## 设置我们的项目

首先我们需要创建一个项目在文件夹 "green_threads" 中, 运行:

> cargo init

由于我们需要使用一些不稳定特性, 所以需要先切换到 `Nightly` 版编译器:

> rustup override set nightly

在我们的 `main.rs` 中我们设置一个特性标签来让我们可以使用 `llvm_asm!` 宏:

> main.rs:
>
> #![feature(llvm_asm)]

