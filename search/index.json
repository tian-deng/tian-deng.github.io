[{"content":" 本译文译自 Peeking inside a Rust enum\n   .dialog { display: flex; flex-direction: row; padding-bottom: 1em; overflow: hidden; } .dialog.amos { flex-direction: row-reverse; } .dialog-head { align-self: flex-start; flex-basis: 48px; width: 48px; height: 48px; margin: 0.2em 0.4em; flex-shrink: 0; } .dialog-text { background-color: #fefdf6; border: 1px solid #ffeb81; max-width: 600px; align-self: flex-start; border-radius: 3px; padding: 0.4rem 0.8rem; overflow: hidden }  前言 在我最近 Rust Q\u0026amp;A twitch 频道里, 有些人提出了一个看起来简单的问题: 为什么 small string 类型, 像 SmartString or SmolStr 和 String 有着一样的大小, 但是 small vec 类型, 像 SmallVec 却要比 Vec 大?\n我知道我使用了简单作为形容词, 但是事实上要了解这个问题, 我们需要一些背景知识\n 译者: 亿点点\u0026hellip;\n 这个问题到底是什么? 我最近谈到 Rust small string crates.\n被这些 crates 导出的类型可以避免多次内存分配, 并且降低内存使用量. 让我们看一个 smartstring 的代码作为例子.\nusesmartstring::{Compact,SmartString};usestd::mem::size_of_val;fn main(){letsmart=SmartString::\u0026lt;Compact\u0026gt;::from(\u0026#34;hello world\u0026#34;);dbg!(size_of_val(\u0026amp;smart));letstand=String::from(\u0026#34;hello world\u0026#34;);dbg!(size_of_val(\u0026amp;stand));}$ cargo run -q [src/main.rs:6] size_of_val(\u0026amp;smart) = 24 [src/main.rs:9] size_of_val(\u0026amp;stand) = 24 正如你看到的, 同样也是最初的问题描述的那样, 这两个类型的大小是相同的.\n毫无疑问的, `String` 存储实际数据是在别的地方? 因为所有 `String` 类型值的大小在64位平台上都是24个字节.\n  是的, 这当然不是一个完整的故事, 在这个特别的例子中, smart 以 inline 的方式存储它的值(在栈上), 而标准库将值存储在堆上:\n如果我们想知道每个类型到底总共使用了多少内存, 我们可以这样做:\nletsmart=SmartString::\u0026lt;Compact\u0026gt;::from(\u0026#34;hello world\u0026#34;);dbg!(size_of_val(\u0026amp;smart));letstand=String::from(\u0026#34;hello world\u0026#34;);dbg!(size_of_val(\u0026amp;stand)+stand.capacity());$ cargo run -q [src/main.rs:6] size_of_val(\u0026amp;smart) = 24 [src/main.rs:9] size_of_val(\u0026amp;stand) + stand.capacity() = 35 好吧, 但是 - 你说 String 显而易见在堆中存放它的内容. 有什么方法可以正式这个说法么?   当然有!\n  典型的, 在 Linux 64-bit 系统中栈和堆在虚拟地址中的空间相差很远, 这意味着我们如果打印字符串的元数据的地址和内容的地址, 我们就可以看到:\n SmartString 的元数据和内容在相邻的位置. String 的元数据和内容相距很远.  usesmartstring::{Compact,SmartString};fn main(){letsmart=SmartString::\u0026lt;Compact\u0026gt;::from(\u0026#34;hello world\u0026#34;);letsmart_meta=\u0026amp;smartas*const_;letsmart_data=\u0026amp;smart.as_bytes()[0]as*const_;dbg!((smart_meta,smart_data));letstand=String::from(\u0026#34;hello world\u0026#34;);letstand_meta=\u0026amp;standas*const_;letstand_data=\u0026amp;stand.as_bytes()[0]as*const_;dbg!((stand_meta,stand_data));}$ cargo run -q [src/main.rs:7] (smart_meta, smart_data) = ( 0x00007ffce4cf4728, 0x00007ffce4cf4729, ) [src/main.rs:12] (stand_meta, stand_data) = ( 0x00007ffce4cf47f8, 0x0000555f87686a60, ) 好吧, 我信了. 那么 smart 总是把它的数据存储在栈中吗?\n  不! 只有在小于24字节的时候是存储在栈上的, 就和 String 一样. 我们用稍微长一点的字符串来看看.\nusesmartstring::{Compact,SmartString};fn main(){letinput=\u0026#34;Turns out you can blame your tools *and* be a good craftsperson. Who knew?\u0026#34;;letsmart=SmartString::\u0026lt;Compact\u0026gt;::from(input);letsmart_meta=\u0026amp;smartas*const_;letsmart_data=\u0026amp;smart.as_bytes()[0]as*const_;dbg!((smart_meta,smart_data));letstand=String::from(input);letstand_meta=\u0026amp;standas*const_;letstand_data=\u0026amp;stand.as_bytes()[0]as*const_;dbg!((stand_meta,stand_data));}$ cargo run -q [src/main.rs:9] (smart_meta, smart_data) = ( 0x00007ffd460d0268, 0x0000555f4636ca30, ) [src/main.rs:14] (stand_meta, stand_data) = ( 0x00007ffd460d0338, 0x0000555f4636cac0, ) \u0026hellip;然后我们就可以看到这两个类型的内容现在都放在堆上了.\n","date":"2021-01-13T11:00:00+08:00","image":"https://example.com/posts/translation/rust/peeking_inside_a_rust_enum/cover_huf0a0302560a2de312014d03b723c5fe2_142416_120x120_fill_box_smart1_2.png","permalink":"https://example.com/posts/translation/rust/peeking_inside_a_rust_enum/","title":"深入Rust枚举"},{"content":" 本译文译自 Green Threads Explained in 200 Lines of Rust\n  介绍 这本书目标是通过我们自己编写实现的一个简单可用的绿色线程代码, 来解释绿色线程.\n 所有代码可以在该 Git仓库 找到, 它有两个分支, main 分支仅仅包括代码, commented 分支包含解释我们做了什么的注释.\n 绿色线程, 用户态线程, 协程(goroutines), 纤程(fibers), 它们有多种称谓, 但是简单起见我将会在后续统一称之为绿色线程.\n在这篇文章中我将通过实现一个200行 Rust 绿色线程代码的简单例子来解释它是如何工作的.\n 我们不会使用任何的外部库来确保我们真正的理解发生了什么.\n 谁适合阅读这篇文章 我们深陷在一个兔子坑中, 如果它听起来很可怕, 那么这篇文章可能不适合你, 像曾经一样去做点轻松愉悦的事情吧~\n如果你还是很好奇事情是如何工作的, 那么继续读下去. 你可能听说过 Go 的 goroutines, 或者 Ruby 和 Julia 中等价的那些, 你可能知道它们怎么使用但是又想知道它们是如何工作的, 请继续读下去.\n另外, 如果你是以下这类人的话那也可能比较有趣:\n 你是 Rust 初学者并且想学习更多的特性. 你已经在 Rust社区 中了解讨论过 async/await, Pin, 和为什么需要生成器. 我们将试着把那些都整合在这篇文章中. 或许你想了解 Rust 内联汇编的基础知识. 或许你只是单纯的感兴趣.  Well, 现在加入我们并且试着了解我们需要了解的一切~\n你不需要是一个 Rust 程序员就可以理解本文, 但是我们强烈建议你首先能够知道一些简单的语法, 如果你想亲手尝试编写代码玩玩那么你可能需要获取 Rust 并且学习些基础知识.\n顺便 所有代码都在一个单文件中并且没有额外的依赖, 这意味着你可以简单的开始你的项目来自己亲自尝试, 你也可以在 Rust playground 中运行代码, 但是记住我们的代码是依赖于 nightly 的部分特性, 所以你需要先将编译器切换到 nightly 版本.\n绿色线程 绿色线程解决了编程中的一个通用问题. 你不希望你的代码阻塞 CPU 来阻止 CPU 去做一些有意义的工作. 我们通过多任务来解决这个问题, 这使得我们可以挂起运行中的一块代码去执行另一块代码, 并且在上下文之间切换.\n虽然很容易把它和并行混淆但是它们是两回事. 想象一下, 绿色线程让我们使用现有的资源更加聪明高效的工作, 而并行则是在问题上投入了更多的资源.\n通常有两种途径来做到这一点:\n 抢占式多任务 非抢占式多任务  抢占式多任务 某些外部调度器会停止一个任务并在切换回来之前去执行另一个任务. 在这种情形下任务与之无关, 决策取决于其它的东西(通常是某些调度程序). 内核在操作系统中使用这种方式, 举例来说, 这允许你在单线程系统中使用 UI 的同时来让 CPU 去做一些计算. 我们现在不会在本文中讨论这种线程, 但是我想当你理解了一个范例, 你能够对这两个范例都有很好的掌握.\n非抢占式多任务 这是我们今天所要讲的. 一个任务自己去决定让 CPU 去做一些其他事情比起让它等待当前线程发生些什么. 通常通过 yielding/让出 控制权给调度器来完成的. 一般是在阻塞事情发生的时候让出执行权. 一个简单的例子是 IO操作. 当控制权让出后一个中心调度器指示 CPU 继续其它已经准备好的任务的工作而不是就在那里停滞着.\n背景知识 这部分是本书中最具有技术性的部分, 但是如果我们真的想要理解绿色线程的话就不得不去了解它们, 我保证我会尽可能快地说到点子上来让我们足以开始编写代码.\nHere we go! 首先, 我们将直接干预控制 CPU. 这并不是特别好移植的因为现实有很多种 CPU, 主要思路是一样的, 一些实现细节可能会有些许不同.\n我们在本文中会覆盖到的是使用地更加通用的架构: x86-64\n在这个架构中 CPU 的特点是有一组16个寄存器.\n如果你对图片的其余部分有兴趣的话你可以在 这里 找到它.\n我们感兴趣的是那些被标记为 callee saved 的寄存器.\n 译者: callee-saved 又称作非易失性/被调用者保存寄存器, 当调用者进行过程调用时, 可以期望这些寄存器在被调用者返回后将保持相同的值, 这使被调用者有责任在返回调用者之前保存它们并恢复它们.\n 这些寄存器用于记录我们的上下文: 下一个要运行的指令, 基指针, 栈指针\u0026hellip;\u0026hellip; 我们将会在后面了解更多的细节.\n如果我们想要直接指示 CPU 我们需要编写一小部分汇编代码, 幸运的是在我们的关卡中我们只需要了解一小部分汇编指令. 比如怎么S从寄存器中移动值:\nmov %rsp, %rax  Windows 系有些不同的习惯. 在 Windows 系统上 XMM6:XMM15 也是 callee-saved 寄存器, 如果我们在函数中使用了它们也必须保存和恢复它们. 我们如果在例子中只用 psABI 的话, 那么代码在 Windows 上也能很好的运行.\n 超级快的汇编介绍 首先并且也是最重要的, 汇编语言通常并不是很便携, 每个 CPU 都可能有自己特别的指令, 然而有些指令在当今的桌面电脑上是通用的.\nAT\u0026amp;T 方言是编写 Rust 内联汇编的标准语言, 但是如果我们想的话我们也可以在 Rust 中使用 Intel 方言. Rust 主要把内联汇编留给 LLVM 处理, LLVM 的内联汇编在语法上非常接近我们在 C 中编写的内联汇编. 这就可以让我们可以通过 C inline ASM 来学习(但并不完全相同).\n我们将会在我们的例子中使用 AT\u0026amp;T 方言.\n汇编有着非常强的向后兼容性保证. 这也是为什么你可能会看到用不同的方法来寻址相同的寄存器. 让我们看看 %rax 寄存器来解释我们之前所说的.\n%rax # 64 bit register (8 bytes) %eax # 32 low bits of the \u0026quot;rax\u0026quot; register %ax # 16 low bits of the \u0026quot;rax\u0026quot; register %ah # 8 high bits of the \u0026quot;ax\u0026quot; part of the \u0026quot;rax\u0026quot; register %al # 8 low bits of the \u0026quot;ax\u0026quot; part of the \u0026quot;rax\u0026quot; register 就像你看到的那样, 这就像是看到了 CPU 的发展历史~从8位到16位到32再到如今的64位. 因为现今大部分 CPU 都是64位的, 所以我们将在我们的代码中使用 64 位寄存器.\nword/字 的大小在汇编中有着历史原因, 它起源于 CPU 有16位数据总线的时候, 所以一个字是16位. 这与我们使用的 AT\u0026amp;T 方言是有关联性的, 因为我们后面将会使用一些以字作为后缀的命令, 比如: q/quad-word, l/long-word, 所以 movq 表示 4 * 16 = 64 bits.\nmov 使用的大小取决于你使用的寄存器, 这是标准 Intel 方言并且也是我们接下来在代码中使用的标准.\n我们将会在下一个章节中遨游更多的内联汇编的语法.\n一个小贴士: 栈对齐在 x86-64 架构上是16位. 请在之后记住这一点~\n一个建立于可编译基础上的例子  在这个例子中我们将创建自己的栈并且使我们的 CPU 从当前执行的上下文到我们刚刚创建的栈中. 我们将在接下来的文字中建立这些概念(但我们不会基于代码).\n 设置我们的项目 首先我们需要创建一个项目在文件夹 \u0026ldquo;green_threads\u0026rdquo; 中, 运行:\n cargo init\n 由于我们需要使用一些不稳定特性, 所以需要先切换到 Nightly 版编译器:\n rustup override set nightly\n 在我们的 main.rs 中我们设置一个特性标签来让我们可以使用 llvm_asm! 宏:\n// main.rs: #![feature(llvm_asm)]让我们在这里设置一个48字节的栈大小以让我们在切换上下文之前可以打印看看它:\n// main.rs: constSSIZE: isize =48; 在 OSX 系统上使用这么小的栈可能会有些问题, 最小的可运行栈大小是624字节. 如果你想原模原样的照抄, 这些代码是可以在 Rust Playground 上运行的(但是由于我们后面编写的无限循环, 你可能需要等~30秒运行才能超时结束).\n 接下来让我们写一个结构体来表示我们的 CPU 状态. 我们现在所需要关注的仅仅是保存栈指针的寄存器:\n// main.rs #[derive(Debug, Default)]#[repr(C)]struct ThreadContext{rsp: u64,}在后面的例子中我将使用我上面链接文档中被标记为 callee saved 的所有寄存器. 那些是在 x86-64 ABI 中描述的寄存器, 我们需要使用它们来保存上下文, 但是现在我们只需要其中一个来让 CPU 跳转到我们的栈中.\n注意 #[repr(C)], 因为我们使用汇编的方式来访问我们的数据. Rust 没有一个稳定的 ABI 所以我们没有办法确保 rsp 在我们的内存中以前8个字节表示. C 有稳定的 ABI, 这个属性就是告诉编译器该结构体使用 C 的内存布局方式. 我们的结构体目前只有一个字段, 当然我们会在后面添加更多~\n// main.rs fn hello()-\u0026gt; !{println!(\u0026#34;I LOVE WAKING UP ON A NEW STACK!\u0026#34;);loop{}}在这个简单的示例中我们仅仅是定义了一个打印一段话的函数, 然后无限循环.\n下一步是我们用来切换到我们的栈的内联汇编.\nunsafefn gt_switch(new: *constThreadContext){llvm_asm!(\u0026#34;mov0x00($0),%rspret\u0026#34;: : \u0026#34;r\u0026#34;(new): : \u0026#34;alignstack\u0026#34;// 不会在现在工作, 后面会用到. );}我们使用了一个小技巧. 我们在我们的新栈上写入我们想要运行的函数的地址, 然后我们把存储该地址第一个字节的地址传递给 rsp 寄存器(我们设置为 new.rsp 的地址将会指向我们栈的地址, 这个栈的地址指向上面的函数). 明白了吗?\nret 关键字将程序的控制权转给栈顶返回的地址. 因为我们把我们的地址 pushed 到 %rsp 寄存器中, CPU 将会认为这个地址是当前正在运行的函数返回的地址, 所以当我们使用 ret 指令时它将直接返回到我们自己的栈中(也就是new的地址).\n然后 CPU 做的第一件事就是读取我们函数的地址并运行它.\n 译者: 关于汇编这里, 新版本的 Rust 使用的是 asm! 宏, 模板语法也有些变化, llvm_asm! 废弃了, 后续会更新为 asm! 宏的版本\u0026hellip;大概.\n 快速介绍 Rust 的内联汇编宏 如果你以前没用过内联汇编你可能会觉得那些看上去像是火星文, 但是我们稍后会使用这个拓展版本来切换上下文, 所以现在我们将逐行解释我们做了什么.\nunsafe 是一个关键字, 它让 Rust 不能强制确保我们编写的函数的安全性. 因为我们直接操作 CPU, 这绝对是不安全的.\nfn gt_switch(new: *constThreadContext)在这里我们获取了一个指向 ThreadContext 实例的指针, 从中我们只读取了一个字段.\nllvm_asm!()这是 Rust 标准库中的 llvm_asm! 宏. 它会检查我们的汇编语法, 如果遇到一些看起来不像是 AT\u0026amp;T 方言的语法, 它将提供一个错误信息.\n宏首先接收的参数是一个汇编模板:\nmov 0x00($0), %rsp 这是一个简单的指令, 它将存储在 $0 位置 的 0x00(16进制表示, 这里表示不偏移) 偏移量的值移动到 rsp 寄存器中. 因为 rsp 寄存器保存一个指向栈中下一个值的指针, 我们有效地将我们提供的地址 push 到当前的栈顶来覆盖原先存在的地址.\n你可能认为 $0 看起来不是一个普通的汇编代码. 这是汇编模板的部分, 表示第一个参数的占位符. 这个参数从0, 1, 2\u0026hellip;计数, 首先是 output 参数, 紧接着是 input 参数. 我们在这里只使用了对应于 $0 的输入参数.\n如果在汇编中碰到 $ 符号可能大部分时候表示一个立即数(常量整数)但是这是有依赖的(yeah, $ 在不同的方言或者是不同的架构如 x86 与 x86-64 之间都表示不同的意义).\n 译者: 在 llvm_asm! 宏中, 使用 : 来分割参数, 所以第一个 : 后面的是输出参数(我们没有用到), 第二个为输入参数\u0026hellip;\n ret ret 关键字命令 CPU 弹出栈顶的内存位置并且无条件地跳转到该位置. 实际上我们劫持了 CPU 让它返回到我们的栈中.\noutput : 内联 ASM 和普通的 ASM 有一点不同. 我们有四个额外的参数需要传递到汇编模板中. 第一个是输出参数, 我们在这里传递我们想要用作 Rust 函数返回值的参数.\n举个例子:\nfn add(a: i32,b: i32)-\u0026gt; i32 {letc: i32;unsafe{llvm_asm!(\u0026#34;add $2, $0\u0026#34;: \u0026#34;=r\u0026#34;(c): \u0026#34;0\u0026#34;(a),\u0026#34;r\u0026#34;(b));}c}这里的输出参数为 c, 最终结果会保存在变量 c 中.\ninput : \u0026quot;r\u0026quot;(new) 第二个表示我们的输入参数, 在内联汇编中 r 被称作约束. 你可以使用一些约束来有效地命令编译器能够决定将我们的输入放到哪里(在一个寄存器中作为值或者使用它作为一个内存地址). r 意味着它将被放置在由编译器选择的通用寄存器中. 内联汇编的约束是一个很大的主题, 幸运的是我们只需要简单的了解.\nclobber list : 下一个参数是 clobber 列表, 可以放置我们不想让编译器接触的寄存器, 并且让编译器知道我们想要在自己的汇编代码中管理那些寄存器. 如果我们弹出栈的任何值, 我们需要让编译器知道哪些寄存器它不能随便使用, 那么就需要在这里指定. 由于我们返回了一个全新的栈所以在这里不需要它.\noptions : \u0026quot;alignstack\u0026quot; 最后一个参数是 options. 这是 Rust 特有的, 有三个选项可以设置: \u0026ldquo;alignstack\u0026rdquo;, \u0026ldquo;volatile\u0026rdquo;, \u0026ldquo;intel\u0026rdquo;. 我倾向你访问该 文档 来获取解释. 值得注意的是我们需要 \u0026ldquo;alignstack\u0026rdquo; 来让我们的代码在 Windows 上工作.\n运行我们的例子 fn main(){letmutctx=ThreadContext::default();letmutstack=vec![0_u8;SSIZEasusize];unsafe{letstack_bottom=stack.as_mut_ptr().offset(SSIZE);letsb_aligned=(stack_bottomasusize\u0026amp;!15)as*mutu8;std::ptr::write(sb_aligned.offset(-16)as*mutu64,helloasu64);ctx.rsp=sb_aligned.offset(-16)asu64;gt_switch(\u0026amp;mutctx);}}这下我们确切的设计了我们自己的栈. hello 是一个指针(一个函数指针)所以我们可以直接把它转成 u64, 因为所有的指针在64位操作系统上是 u64. 然后我们把这个指针写到我们的栈里.\n 我们会在下一个章节更多的讨论这个栈, 但是现在有件需要我们知道的事是栈是向下增长的. 如果我们的栈从索引0开始, 结束于索引47. 那么32就是从堆栈末尾开始偏移16个字节的第一位.\n 请注意, 我们将指针写入到距离栈底部16个字节偏移的位置.\n 这行做了什么 let sb_aligned = (stack_bottom as usize \u0026amp;! 15) as *mut u8?\n我们申请了一个 Vec\u0026lt;u8\u0026gt; 的内存, 但是没有任何保证我们得到的是16字节对齐的地址, 这行将地址四舍五入到最近的16字节对齐. 如果已经16字节对齐了那什么也不会做.\n 我们把指针强制转换成 u64 而不是 u8. 我们想要写入的是32,33,34,35,36,37,38,39这八个字节, 如果我们不做这个转换那么则仅仅是尝试把 u64 的指针写入到32处, 这不是我们想要的.\n我们设置了 rsp 为我们的栈索引32的位置, 我们不传递存储在那里的64位的值, 而是第一个字节的地址.\n当我们用 cargo run 运行我们的代码:\nFinished dev [unoptimized + debuginfo] target(s) in 0.58s Running `target\\debug\\green_thread_start.exe` I LOVE WAKING UP ON A NEW STACK! ok, 所以发生了什么? 我们在任何地方都没有调用 hello 函数但是它确实运行了. 我们实际上让 CPU 直接跳到我们的栈并且运行那里的代码. 我们实现了上下文切换的第一步.\n在下一个章节我们在实现我们的绿色线程前将会讲一下我们的栈. 我们已经讲了那么多基础知识了, 所以事情会很简单.\n栈  栈不过是一块连续的内存空间.\n 这一点很重要, 电脑只有内存, 没有所谓的 \u0026ldquo;栈\u0026rdquo; 内存和 \u0026ldquo;堆\u0026rdquo; 内存, 它们都是同一个内存的一部分.\n它们的不同是怎么访问和使用内存. 栈在连续的内存空间支持简单的 push/pop 命令, 这使得它们用起来会很快. 堆则是由内存分配器根据需要而分配的, 可能分散在不同的位置.\n我们不会在这里探讨堆和栈的不同, 因为有许多文章都有讨论包括 The Rust Programming Language 的其中一章.\n一个栈看起来长什么样子 让我们从一个简化的栈视图开始. 一个64位 CPU 每次读取8个字节, 尽管我们普通看到的栈是一长行的 u8, 但我们传递指针的时候需要确保我们传递的是 0016, 0008 或者 0000.\n栈是向下增长的, 所以我们从顶部开始向下进行.\n当我们设置一个16字节对齐的栈指针, 我们需要确保把我们的栈指针放在16倍数的地址, 在上面的地址中, 唯一满足条件的地址是 0008 (记住栈是从顶部开始的).\n如果我们在上一章例子中主函数切换之前加入如下几行代码, 我们可以有效地打印我们的栈并查看它.\nforiin(0..SSIZE).rev(){println!(\u0026#34;mem: {}, val: {}\u0026#34;,stack_ptr.offset(iasisize)asusize,*stack_ptr.offset(iasisize))}我们得到的输出:\nmem: 94846750517871, val: 0 mem: 94846750517870, val: 0 mem: 94846750517869, val: 0 mem: 94846750517868, val: 0 mem: 94846750517867, val: 0 mem: 94846750517866, val: 0 mem: 94846750517865, val: 0 mem: 94846750517864, val: 0 mem: 94846750517863, val: 0 mem: 94846750517862, val: 0 mem: 94846750517861, val: 86 mem: 94846750517860, val: 67 mem: 94846750517859, val: 56 mem: 94846750517858, val: 252 mem: 94846750517857, val: 205 mem: 94846750517856, val: 240 mem: 94846750517855, val: 0 mem: 94846750517854, val: 0 mem: 94846750517853, val: 0 mem: 94846750517852, val: 0 mem: 94846750517851, val: 0 mem: 94846750517850, val: 0 mem: 94846750517849, val: 0 mem: 94846750517848, val: 0 mem: 94846750517847, val: 0 mem: 94846750517846, val: 0 mem: 94846750517845, val: 0 mem: 94846750517844, val: 0 mem: 94846750517843, val: 0 mem: 94846750517842, val: 0 mem: 94846750517841, val: 0 mem: 94846750517840, val: 0 mem: 94846750517839, val: 0 mem: 94846750517838, val: 0 mem: 94846750517837, val: 0 mem: 94846750517836, val: 0 mem: 94846750517835, val: 0 mem: 94846750517834, val: 0 mem: 94846750517833, val: 0 mem: 94846750517832, val: 0 mem: 94846750517831, val: 0 mem: 94846750517830, val: 0 mem: 94846750517829, val: 0 mem: 94846750517828, val: 0 mem: 94846750517827, val: 0 mem: 94846750517826, val: 0 mem: 94846750517825, val: 0 mem: 94846750517824, val: 0 I LOVE WAKING UP ON A NEW STACK! 我以 u64 打印了内存地址所以如果你对16进制不是很熟悉的话那这个更容易解析点.\n第一件事就是注意到这仅仅是一段连续的内存, 从 94846750517824 开始, 94846750517871 结束.\n地址 94846750517856 到 94846750517863 是我们感兴趣的一块. 第一个地址是我们栈指针的地址, 它的值我们写入到了 CPU 的 %rsp 寄存器中. 这个范围表示我们在切换上下文之前写入到栈的值.\n换句话说, 240,205,252,56,67,86,0,0 是我们写为u8 的 hello() 函数的指针.\n 这里有一个有趣的附带说明, CPU 将 u64 作为 u8 写入的顺序取决于它是用的大端法还是小端法. 如果你手动解析这些数字, 请务必记住这一点.\n 在我们写更加复杂的程序时我们非常小的48字节的栈很快就会用完了, 你明白的, 当我们运行在 Rust 中编写的函数时, 代码将指示 CPU 在我们的栈上 pop 和 push 值来运行我们的程序.\n栈大小 在大多数现代操作系统中启动一个进程时标准栈的大小通常是8MB, 但也是可以配置为别的. 对于大多数程序来说这已经够了但是要由程序员来确保使用的栈不会超出拥有的栈大小. 这是我们大多数程序员经历 \u0026ldquo;stack overflow\u0026rdquo; 的原因.\n然而, 当我们自己控制栈的时候我们能选择我们自己想要的大小. 首先, 8MB对于一个运行在 web 服务的例子来说已经远远超出所需了, 所以我们可以减少栈大小来在一个机器上有上百万的绿色线程, 而用操作系统提供的栈则会很快地耗尽内存.\n可增长栈 有一些实现使用的是可增长栈, 这允许我们为大多数任务分配足够用的一小部分内存给栈空间, 但是在用完后不会发生 \u0026ldquo;stack overflow\u0026rdquo;, 而是分配一个新的更大的栈并且把所有东西都移到这个新栈里, 在新栈里可以恢复程序的执行.\nGO 就是这样的一个例子. 它从8KB的栈开始当超出后就会重新分配一个更大的栈. 就像编程中的每件事一样, 这也是需要一定的取舍, 所有的指针需要自己保证正确地更新, 这不是一个简单的任务. 如果你对 GO 如何操作栈有兴趣(一个很好的例子在权衡和使用可增长栈上). 我建议你读这篇文章: how-stacks-are-handled-in-go.\n 要说明一些重要的事: 我们使用了标准库中普通的 Vec\u0026lt;u8\u0026gt; 来作为栈, 这很方便但是会有一些问题. 换句话说, 我们没法保证它在内存中的位置一直不变.\n就像你所想的, 如果栈移动到一个不同的地址空间, 那么我们的程序可能就会崩溃因为所有的指针就会失效. 很简单的 push 操作可能会使 vec 拓展到一个新的更大的内存空间, 然后其中的值会被移动到那里.\n OK, 现在我们已经学习了栈长什么样子, 是如何工作的, 我们已经准备好去实现我们的绿色线程了. 你已经做完了艰难的工作所以我保证我们可以写更多的代码了.\n如何设置栈 Windows x64-86 的栈设置与 x64-86 psABI 的调用约定有一些不同. 我将在附录 Windows支持 中更多的讲关于 Windows 的栈. 不过有件重要的事要说, 如果像我们这样只是用简单不带参数的函数来设置堆栈, 那么它们不会有太多的不同.\npsABI 栈布局长这样:\n如你所看到的 %rsp 是我们的栈指针. 我们需要把栈指针放在从基地址开始16的倍数的地方. 返回的地址位于相邻的8个字节中, 其上还有一个存储内存参数的房间. 当我们想要做更复杂的事情的时候我们必须牢记这点.\n你会注意到我们通常把函数地址写入到 stack_ptr + SSIZE - 16 而没有进行说明. 顺便说一下 SSIZE 是栈的字节大小.\n这么说吧, 我们知道一个指针(在例子里是函数指针)的大小是8字节. 我们也知道我们需要把 rsp 写入到16字节的边界中.\n我们除了把函数指针写入到 stack_ptr + SSIZE - 16 以外没有其它的选择. 因为我们从低到高写入我们的地址:\n 不能将它写入到 stack_ptr + SSIZE(也是16字节的倍数) 因为这可能导致写入的字节超出我们分配的内存, 那是不被允许的(因为我们为了16字节对齐而进行了四舍五入). 不能写入到 stack_ptr + SSIZE - 8, 虽然它也是一个有效的内存空间, 但是它没有对齐16字节的边界.  由于这些原因因此 stack_ptr + SSIZE - 16 是第一个合适的位置. 在我们的代码中, 我们写入了8个字节在位置: -16,-15,\u0026hellip;,-10,-9 从我们栈的高地址开始(这通常称为栈的底部, 因为栈是向下增长, 这可能有些令人困惑).\n幕后花絮 如果你足够好奇, 你可能会思考在我们切换栈之后发生了什么?\n答案是我们在 Rust 写的代码编译为 CPU 指令, 然后它接管并像使用其它栈一样使用我们的栈.\n然而不幸的是如果想证明这一点那我不得不把栈大小增加到1024字节来允许代码有足够的空间打印出栈本身. 所以我们不会在这打印它来证明这点.\n看一眼栈 我又做了一个我们代码例子的修改版本, 你可以打印内容到两个文本文件中, BEFORE.txt 打印我们的在切换之前的栈, AFTER.txt 打印切换后的栈. 然后你就可以自己看看栈是如何被我们的代码激活和使用.\n 如果你发现里面有些你看不懂的东西, 放松, 我们会很快彻底的进行解释.\n #![feature(llvm_asm)]#![feature(naked_functions)]usestd::io::Write;constSSIZE: isize =1024;staticmutS_PTR: *constu8=0as*constu8;#[derive(Debug, Default)]#[repr(C)]struct ThreadContext{rsp: u64,r15: u64,r14: u64,r13: u64,r12: u64,rbx: u64,rbp: u64,}fn print_stack(filename: \u0026amp;str){letmutf=std::fs::File::create(filename).unwrap();unsafe{foriin(0..SSIZE).rev(){writeln!(f,\u0026#34;mem: {}, val: {}\u0026#34;,S_PTR.offset(iasisize)asusize,*S_PTR.offset(iasisize)).expect(\u0026#34;Error writing to file.\u0026#34;);}}}fn hello(){println!(\u0026#34;I LOVE WAKING UP ON A NEW STACK!\u0026#34;);print_stack(\u0026#34;AFTER.txt\u0026#34;);loop{}}unsafefn gt_switch(new: *constThreadContext){llvm_asm!(\u0026#34;mov0x00($0),%rspret\u0026#34;: : \u0026#34;r\u0026#34;(new): : \u0026#34;alignstack\u0026#34;);}fn main(){letmutctx=ThreadContext::default();letmutstack=vec![0_u8;SSIZEasusize];letstack_ptr=stack.as_mut_ptr();unsafe{S_PTR=stack_ptr;std::ptr::write(stack_ptr.offset(SSIZE-16)as*mutu64,helloasu64);print_stack(\u0026#34;BEFORE.txt\u0026#34;);ctx.rsp=stack_ptr.offset(SSIZE-16)asu64;gt_switch(\u0026amp;mutctx);}}一个绿色线程的实现 在开始之前, 我先说明我们编写的代码非常不安全并且也不是最佳实践, 我希望尽可能编写安全代码的同时不引入额外的复杂度, 所以我鼓励亲爱的读者们如果你们有更好的方案来让代码变得更加安全并且也不会太复杂的话, 欢迎给我的仓库提PR.\n让我们开始吧 首先我们把 main.rs 文件中的内容替换如下:\n#![feature(llvm_asm)]#![feature(naked_functions)]usestd::ptr;constDEFAULT_STACK_SIZE: usize =1024*1024*2;constMAX_THREADS: usize =4;staticmutRUNTIME: usize =0;我们启用了两个特性, asm 在之前有讲到, 接下来我们需要解释下 naked_functions 特性.\nnaked_functions 当 Rust 编译一个函数的时候, 可能会给每个函数添加开场白和后记, 而这可能会导致没有对齐栈以至于我们在切换上下文的时候出现问题. 在我们的第一个简单示例中可能没出现什么问题, 但是一旦我们需要再次切换到相同的栈, 就会遇到麻烦. 将函数标记为 #[naked] 可以移除开场白和后记. 此属性主要用于内联汇编.\n 如果你对该属性感兴趣, 想了解更多, 可以参照 RFC #1201.\n 我们将 DEFAULT_STACK_SIZE 设置为2MB, MAX_THREADS 设置为4, 这已经足够我们并且远超我们编写的绿色线程所需了.\n最后一个常量 RUNTIME 是我们运行时的指针(是的我知道使用可变全局变量不是很好, 但是我们需要这样并且仅仅在运行时初始化的时候设置该变量).\n 译者: Rust 新特性const function是不是可以解决这个问题?\n 让我们开始充实我们的代码:\npubstruct Runtime{threads: Vec\u0026lt;Thread\u0026gt;,current: usize,}#[derive(PartialEq, Eq, Debug)]enum State{Available,Running,Ready,}struct Thread{id: usize,stack: Vec\u0026lt;u8\u0026gt;,ctx: ThreadContext,state: State,}#[derive(Debug, Default)]#[repr(C)]struct ThreadContext{rsp: u64,r15: u64,r14: u64 r13: u64 r12: u64 rbx: u64 rbp: u64 }Runtime 将会成为我们主要的入口点. 基本上, 我们将会创建一个非常小的运行时来调度切换我们的线程. 这个运行时持有一个 Threads 的数组和一个 current 属性来表明当前运行的线程.\nThread 持有了一个线程应有的数据. 每个线程有一个 id 来让我们分辨它们. stack 和我们在第一个例子中看到的类似. ctx 域是一个表示我们 CPU 所需要恢复的数据在堆栈上位置的上下文, 这些数据要在调度的时候得以恢复. state 表示我们线程的状态.\nState 是一个用来表示我们线程状态的枚举:\n Available 意味着线程已经准备好被分配一个任务如果需要的话. Running 意味着该线程已经运行了. Ready 意味着该线程准备好继续向前并恢复执行.  ThreadContext 持有着 CPU 恢复在栈上执行所需的寄存器数据.\n 如果你不记得寄存器了, 返回 Background Information 章节来阅读寄存器相关. 那里有一些在 x86-64 架构上标记为 callee saved 的寄存器.\n 让我们继续:\nimplThread{fn new(id: usize)-\u0026gt; Self{Thread{id,stack: vec![0_u8;DEFAULT_STACK_SIZE],ctx: ThreadContext::default(),state: State:Available,}}}这相当简单. 一个新的线程从 Available 状态开始表明它已经准备好被分配一个任务.\n需要注意的点, 我们在这里分配栈. 这并不必要而且也不是资源使用的好方法, 我们应该在线程需要的时候分配而不是第一次使用 new 时就分配. 然而这降低了我们这部分代码的复杂度, 这更加重要比起去关注如何给我们的栈分配内存.\n 重要的一点, 一旦给栈分配了内存就不能再移动它! 不能使用 push() 或其它可能触发 vector 重分配内存的方法. 在该代码更好的版本中, 我们可以包装 vector 并且仅公开我们认为可以安全使用的方法.\n值得一提的是, Vec\u0026lt;T\u0026gt; 有一个 into_boxed_slice() 方法, 该方法返回一个堆分配的切片 Box\u0026lt;T\u0026gt;. 切片不能增长, 所以我们如果用它代替的话可以解决重分配问题.\n 实现运行时 该部分中所有的代码都是 impl Runtime 块中的, 这意味着它们都是 Runtime 结构体的方法.\nimplRuntime{pubfn new()-\u0026gt; Self{// This will be our base thread, which will be initialized in // the `running` state letbase_thread=Thread{id: 0,stack: vec![0_u8;DEFAULT_STACK_SIZE],ctx: ThreadContext::default(),state: State::Running,};letmutthreads=vec![base_thread];letmutavailable_threads: Vec\u0026lt;Thread\u0026gt;=(1..MAX_THREADS).map(|i|Thread::new(i)).collect();threads.append(\u0026amp;mutavailable_threads);Runtime{threads,current: 0,}}}当我们实例化 Runtime 的时候我们设置了一个基线程. 这个线程被设置为 Running 状态并且确保在所有任务完成之前保持运行时持续地运行.\n然后我们实例化其它线程, 并将当前线程设置为0 , 这是我们的基线程.\n/// This is cheating a bit, but we need a pointer to our Runtime /// stored so we can call yield on it even if we don\u0026#39;t have a /// reference to it pubfn init(\u0026amp;self){unsafe{letr_ptr: *constRuntime=self;RUNTIME=r_ptrasusize;}}现在我们需要这个, 就像我提到过的当我们遍历我们的常量的时候我们需要能够在后续调用 yield, 它并不漂亮, 但是我们知道只要有任何线程 yield 我们的运行时就会存活着, 只要我们不滥用它那就是安全的.\npubfn run(\u0026amp;mutself)-\u0026gt; !{whileself.t_yield(){}std::process::exit(0);}这是我们开始运行时的地方, 它将持续调用 t_yield() 直到返回 false, 那时候意味着没有更多的任务需要再做了, 所以我们可以退出程序了.\nfn t_return(\u0026amp;mutself){ifself.current!=0{self.threads[self.current].state=Stete::Available;self.t_yield();}}这是当我们线程运行完成后调用的返回函数. return 是 rust 中的保留字所以我们改为了 t_return(). 注意我们线程的用户不能调用它, 当任务完成后我们在我们设置的栈中调用它.\n如果正在调用的线程是 base_thread 那么将什么都不做. 我们的运行时将会在基线程中调用 yield. 如果从一个分发的线程中调用了 t_return() 我们可以知道这个线程已经完成任务了, 我们只会在 guard (后续展示)函数中调用 t_return(), 并且 guard已经在栈顶了.\n我们设置状态为 Available 让运行时知道这个线程已经准备好被分配一个新的任务然后立即调用 t_yield 来调度要运行的新线程.\nNext: 我们的 yield 函数:\nfn t_yield(\u0026amp;mutself)-\u0026gt; bool {letmutpos=self.current;whileself.threads[pos].state!=State::Ready{pos+=1;ifpos==self.threads.len(){pos=0;}ifpos==self.current{returnfalse;}}ifself.threads[self.current].state!=State::Available{self.threads[self.current].state=State::Ready;}self.threads[pos].state=State::Running;letold_pos=self.current;self.current=pos;unsafe{switch(\u0026amp;mutself.threads[old_pos].ctx,\u0026amp;self.threads[pos].ctx);}// Prevents compiler from optimizing our code away on Windows. self.threads.len()\u0026gt;0}这是我们运行时的核心. 我们使用 t_yield() 而不是 yield 因为这是一个 Rust 的保留字.\n我们遍历所有线程来查看是否有人处于 Ready 状态, 这表明该线程已准备就绪可以继续进行.\n如果没有线程是就绪状态的, 我们就运行结束. 这是一个使用循环算法的简单调度器, 真正的调度程序可能具有更复杂的方式来决定下一步要执行的任务.\n 这是定制给我们的粒子的非常幼稚的实现. 想想当我们的线程没有准备好继续(没有在准备状态) 并且在等待一个响应例如数据库.\n解决这个问题并不难, 比起在线程 Ready 时直接运行我们的代码, 我们可以改为轮询它的状态. 举个例子, 如果真的准备好了它可以返回一个 IsReady 或者等待一些其它操作完成那么就 Pending. 在第二种情况, 我们可以将其保持在 Ready 状态以便稍后再次轮询. 它听起来是不是有些熟悉? 如果你读过 Futures 如何在 Rust 中工作, 我们将所有这些点组合串联起来.\n 如果我们发现有一个线程准备就绪, 那么我们就把当前线程的状态从 Running 设置为 Ready 以便后续继续运行它.\n然后我们调用 switch 来保存当前线程的上下文, 然后将新的上下文加载到 CPU 中. 这个新的上下文可以是一个新的任务, 也可能是恢复一个已有任务工作所需的上下文信息.\n最后一行只是我们阻止编译器优化代码的一种方法. 我在 Windows 上会需要这行, 但在 Linux 上不会, 而在基准测试的时候是一个常见问题. 因此我们使用 std::hint::black_box 来阻止编译器为了执行更快而跳过了我们需要执行的一些代码. 我使用了另外一种方法同样OK. 代码无论如何不会运行到这个地方.\n下一个是我们的 spawn() 函数:\npubfn spawn(\u0026amp;mutself,f: fn()){letavailable=self.threads.iter_mut().find(|t|t.state==State::Available).expect(\u0026#34;no available thread.\u0026#34;);letsize=available.stack.len();unsafe{lets_ptr=available.stack.as_mut_ptr().offset(sizeasisize);lets_ptr=(s_ptrasusize\u0026amp;!15)as*mutu8;std::ptr::write(s_ptr.offset(-16)as*mutu64,guardasu64);std::ptr::write(s_ptr.offset(-24)as*mutu64,skipasu64);std::ptr::write(s_ptr.offset(-32)as*mutu64,fasu64);available.ctx.rsp=s_ptr.offset(-32)asu64;}available.state=State::Ready;}我认为 t_yield 是逻辑上有趣的函数同时也是技术上最有趣的.\n这是我们设置我们的栈的地方就像我们在上一章节中讲述的那样, 需要确保我们的栈与 psABI 栈布局 类似.\n当我们 spawn 一个新县城我们首先检查是否有线程是 available 状态. 在这个场景如果我们超出了线程数就会 panic, 虽然有一些更好的操作不过我们目前保持我们的例子.\n当我们找到一个 available 线程我们获取它的栈长度和 u8 字节数组的指针.\n在下一部分我们会使用一些 unsafe 函数. 首先我们应该确保我们使用的内存块是16字节对齐的. 然后把 guard 函数的地址写入栈顶, 这是在任务完成函数返回的时候调用的地方. 其次我们写入 skip 函数的地址, 它只是用来填充 f 和 guard 之间的空隙来满足16字节对齐. 然后把 f 地址写到16字节边界处.\n 记住我们在 The Stack 章节解释的栈是如何工作的. 我们需要让 f 函数第一个运行, 所以我们设置基指针指向 f 并且确保16字节对齐, 然后我们把 skip 的地址压入, 最后是 guard. 这样做可以确保我们遵守 ABI 要求满足 guard 是16字节对齐的.\n 最后我们将状态设置为 Ready 这意味着我们有工作并且也准备好去做了. 记住, 这实际上取决于我们的调度器来启动该线程.\n我们现在完成了我们运行时的实现, 如果你掌握了这些知识, 那么你基本上了解绿色线程是如何工作的. 然而依然有一些细节部分需要实现.\nGuard, skip and switch functions fn guard(){unsafe{letrt_ptr=RUNTIMEas*mutRUNTIME;(*rt_ptr).t_return();};}这个函数表示着我们传进来的函数已经返回意味着我们的线程已经完成了运行它的任务, 所以我们解引用我们的 Runtime 并且调用 t_return. 当一个线程完成的时候我们可能需要做一些额外的工作但现在 t_return 就够了. 这使得我们的线程 Available (如果它不是我们的基线程) 并且 yield 以让我们可以恢复其它线程的工作.\n#[naked]fn skip(){}在 skip 函数里什么也没做. 我们使用 #[naked] 属性, 所以这个函数基本上只是编译为 ret 命令. ret 将会从栈中弹出下一个值并且跳到那个地址指向的任何命令. 在我们的例子中它是 guard 函数. 就像你上一章节看到的那样, 这个函数为了确保我们遵从 ABI 的要求.\npubfn yield_thread(){unsafe{letrt_ptr=RUNTIMEas*mutRUNTIME;(*rt_ptr).t_yield();};}这只是一个帮助函数为了我们可以在任何地方调用 yield. 这很不安全, 如果我们的 Runtime 还没有初始化完成或者运行时已经被释放, 它将会有一个 undefined behavior. 然而我们仅仅是想让我们的示例正常运行, 安全性不是我们优先考虑的.\n我们很快到了最后一部分, 最后一个函数了. 如果你理解了前面的部分那你应该不需要注释也可以理解这个函数:\n#[naked]#[inline(never)]unsafefn switch(old: *mutThreadContext,new: *constThreadContext){llvm_asm!(\u0026#34;mov%rsp,0x00($0)mov%r15,0x08($0)mov%r14,0x10($0)mov%r13,0x18($0)mov%r12,0x20($0)mov%rbx,0x28($0)mov%rbp,0x30($0)mov0x00($1),%rspmov0x08($1),%r15mov0x10($1),%r14mov0x18($1),%r13mov0x20($1),%r12mov0x28($1),%rbxmov0x30($1),%rbpret\u0026#34;: :\u0026#34;r\u0026#34;(old),\u0026#34;r\u0026#34;(new): : \u0026#34;volatile\u0026#34;,\u0026#34;alignstack\u0026#34;);} 译者: 0x10是16进制, 为10进制的16, 所以上面的内联函数是每8个字节交换old和new.\n 这是我们的内联汇编, 就像你在第一个例子中记得的那样只是更复杂一点, 我们首先读取寄存器中的所有我们需要的值然后将所有寄存器中的值设置为 new 线程中挂起执行时保存的值.\n本质上, 这是我们保存和恢复执行所需的全部工作.\n我们再一次看见了 #[naked] 属性. 通常函数都是有开场白和尾声, 但是我们不想要那些因为我们用的都是汇编, 并且我们想要自己掌控一切. 如果我们不使用这个属性我们可能会在第二次切换回我们的栈的时候失败.\n 更多的内联汇编的解释请参考这一章节的结尾部分. 如果这些看起来像火星文那么建议你返回读一下这部分.\n 有两件事情做的与我们的第一个例子不同.\n首先是 #[inline(never)], 这个属性阻止编译器内联这个函数, 我试了很多次, 如果我们不加这个属性那么在 --release 模式编译的话会运行失败.\n\u0026quot;volatile\u0026quot; 选项是另一个. 就像我先前警告的那样, 内联汇编有点啰嗦, 这表明了我们的汇编有副作用. 就是说当我们传入输入参数的时候我们需要确保编译器知道我们改变了传入的参数而不仅仅是读取它们.\n0x00($1) # 0 0x08($1) # 8 0x10($1) # 16 0x18($1) # 24 我之前有简单提到过, 但是我们再看一次. 这些都是 hex 数字表明我们想要从内存指针偏移多少来读写. 我们每次仅仅偏移8个字节这与我们 ThreadContext 结构体中的 u64 属性是相同大小的.\n同样重要的一点需要说明的是 ThreadContext 被 #[repr(C)] 标记着, 所以我们知道数据在内存中表示的方法并且写入正确的字段. Rust ABI 不保证我们的结构体的属性在内存中是按顺序表示的, 而 C-ABI 有保证.\nmain函数 fn main(){letmutruntime=Runtime::new();runtime.init();runtime.spawn(||{println!(\u0026#34;THREAD 1 STARTING\u0026#34;);letid=1;foriin0..10{println!(\u0026#34;thread: {} counter: {}\u0026#34;,id,i);yield_thread();}println!(\u0026#34;THREAD 1 FINISHED\u0026#34;);});runtime.spawn(||{println!(\u0026#34;THREAD 2 STARTING\u0026#34;);letid=2;foriin0..15{println!(\u0026#34;thread: {} counter: {}\u0026#34;,id,i);yield_thread();}println!(\u0026#34;THREAD 2 FINISHED\u0026#34;);});runtime.run();}正如你看到的那样, 我们初始化运行时并且发放了两个线程, 一个从1计数到10, 在每次计数之间让出控制权/yield, 而另一个计数到15. 我们可以使用 cargo run 来运行我们的项目, 我们可以看到以下输出:\nFinished dev [unoptimized + debuginfo] target(s) in 2.17s Running `target/debug/green_threads` THREAD 1 STARTING thread: 1 counter: 0 THREAD 2 STARTING thread: 2 counter: 0 thread: 1 counter: 1 thread: 2 counter: 1 thread: 1 counter: 2 thread: 2 counter: 2 thread: 1 counter: 3 thread: 2 counter: 3 thread: 1 counter: 4 thread: 2 counter: 4 thread: 1 counter: 5 thread: 2 counter: 5 thread: 1 counter: 6 thread: 2 counter: 6 thread: 1 counter: 7 thread: 2 counter: 7 thread: 1 counter: 8 thread: 2 counter: 8 thread: 1 counter: 9 thread: 2 counter: 9 THREAD 1 FINISHED. thread: 2 counter: 10 thread: 2 counter: 11 thread: 2 counter: 12 thread: 2 counter: 13 thread: 2 counter: 14 THREAD 2 FINISHED. 漂亮, 我们的线程是交替的, 因为我们在每个计数之间让出控制权直到线程1完成, 线程2在完成任务之前继续剩下的计数.\n恭喜 你现在已经实现了一个超级简单但是能运行的绿色线程例子. 这是我们必须经历的一段旅程, 如果你已经读了很久完全理解了这些, 现在你应该休息一会了. 谢谢阅读!\n完成的200行代码 #![feature(llvm_asm, naked_functions)]constDEFAULT_STACK_SIZE: usize =1024*1024*2;constMAX_THREADS: usize =4;staticmutRUNTIME: usize =0;pubstruct Runtime{threads: Vec\u0026lt;Thread\u0026gt;,current: usize,}#[derive(PartialEq, Eq, Debug)]enum State{Available,Running,Ready,}struct Thread{id: usize,stack: Vec\u0026lt;u8\u0026gt;,ctx: ThreadContext,state: State,}#[derive(Debug, Default)]#[repr(C)]struct ThreadContext{rsp: u64,r15: u64,r14: u64,r13: u64,r12: u64,rbx: u64,rbp: u64,}implThread{fn new(id: usize)-\u0026gt; Self{Thread{id,stack: vec![0_u8;DEFAULT_STACK_SIZE],ctx: ThreadContext::default(),state: State::Available,}}}implRuntime{pubfn new()-\u0026gt; Self{letbase_thread=Thread{id: 0,stack: vec![0_u8;DEFAULT_STACK_SIZE],ctx: ThreadContext::default(),state: State::Running,};letmutthreads=vec![base_thread];letmutavailable_threads: Vec\u0026lt;Thread\u0026gt;=(1..MAX_THREADS).map(|i|Thread::new(i)).collect();threads.append(\u0026amp;mutavailable_threads);Runtime{threads,current: 0,}}pubfn init(\u0026amp;self){unsafe{letr_ptr: *constRuntime=self;RUNTIME=r_ptrasusize;}}pubfn run(\u0026amp;mutself)-\u0026gt; !{whileself.t_yield(){}std::process::exit(0);}fn t_return(\u0026amp;mutself){ifself.current!=0{self.threads[self.current].state=State::Available;self.t_yield();}}fn t_yield(\u0026amp;mutself)-\u0026gt; bool {letmutpos=self.current;whileself.threads[pos].state!=State::Ready{pos+=1;ifpos==self.threads.len(){pos=0;}ifpos==self.current{returnfalse;}}ifself.threads[self.current].state!=State::Available{self.threads[self.current].state=State::Ready;}self.threads[pos].state=State::Running;letold_pos=self.current;self.current=pos;unsafe{switch(\u0026amp;mutself.threads[old_pos].ctx,\u0026amp;self.threads[pos].ctx);}self.threads.len()\u0026gt;0}pubfn spawn(\u0026amp;mutself,f: fn()){letavailable=self.threads.iter_mut().find(|t|t.state==State::Available).expect(\u0026#34;no available thread.\u0026#34;);letsize=available.stack.len();unsafe{lets_ptr=available.stack.as_mut_ptr().offset(sizeasisize);lets_ptr=(s_ptrasusize\u0026amp;!15)as*mutu8;std::ptr::write(s_ptr.offset(-16)as*mutu64,guardasu64);std::ptr::write(s_ptr.offset(-24)as*mutu64,skipasu64);std::ptr::write(s_ptr.offset(-32)as*mutu64,fasu64);available.ctx.rsp=s_ptr.offset(-32)asu64;}available.state=State::Ready;}}#[naked]fn skip(){}fn guard(){unsafe{letrt_ptr=RUNTIMEas*mutRuntime;(*rt_ptr).t_return();};}pubfn yield_thread(){unsafe{letrt_ptr=RUNTIMEas*mutRuntime;(*rt_ptr).t_yield();};}#[naked]#[inline(never)]unsafefn switch(old: *mutThreadContext,new: *constThreadContext){llvm_asm!(\u0026#34;mov%rsp,0x00($0)mov%r15,0x08($0)mov%r14,0x10($0)mov%r13,0x18($0)mov%r12,0x20($0)mov%rbx,0x28($0)mov%rbp,0x30($0)mov0x00($1),%rspmov0x08($1),%r15mov0x10($1),%r14mov0x18($1),%r13mov0x20($1),%r12mov0x28($1),%rbxmov0x30($1),%rbpret\u0026#34;: :\u0026#34;r\u0026#34;(old),\u0026#34;r\u0026#34;(new): : \u0026#34;volatile\u0026#34;,\u0026#34;alignstack\u0026#34;);}fn main(){letmutruntime=Runtime::new();runtime.init();runtime.spawn(||{println!(\u0026#34;THREAD 1 STARTING\u0026#34;);letid=1;foriin0..10{println!(\u0026#34;thread: {} counter: {}\u0026#34;,id,i);yield_thread();}println!(\u0026#34;THREAD 1 FINISHED\u0026#34;);});runtime.spawn(||{println!(\u0026#34;THREAD 2 STARTING\u0026#34;);letid=2;foriin0..15{println!(\u0026#34;thread: {} counter: {}\u0026#34;,id,i);yield_thread();}println!(\u0026#34;THREAD 2 FINISHED\u0026#34;);});runtime.run();} 译者: 下一个章节是对 Windows 的额外支持, 有兴趣的可以自行阅读.\n如果翻译有任何问题, 欢迎给我提 issue.\n ","date":"2020-11-18T13:28:44+08:00","image":"https://example.com/posts/translation/rust/green_threads_explained_in_200_lines_of_rust/cover_hud99fec317f0d171bfccb5e21f0f08cf5_179342_120x120_fill_box_smart1_2.png","permalink":"https://example.com/posts/translation/rust/green_threads_explained_in_200_lines_of_rust/","title":"200行Rust代码解释绿色线程"},{"content":" TODO: 对本版博文不是很满意, 后续重新更新~\n 建立仓库 我跟同学A想合作写一个小工具库，然后选了了 Git 作为版本控制系统, Github 作为托管服务器.\n第一步首先是建立一个 Git 仓库, 哦不对, 是先下载 Git 工具, Git 是全平台的工具, 基本所有操作系统都支持. 我们直接百度找到官网从里面下载就可以了.\n然后建立 Git 仓库, 我们怎么建立仓库呢? 有两种方法, 一种是在Github上创建一个新仓库.\n登录Github后, 它长这样, 点击左边那个New来创建一个新的仓库.\n如果想让 Github 帮我们初始化仓库, 那么就选择Add a README file选项. README file一般是对当前仓库所做的事情的一个简介. 相当于使用说明书.\n让Github帮我们初始化, 就相当于运行了如下命令:\ngit init git add README.md git commit -m \u0026#34;Initial commit\u0026#34; git remote add origin git@github.com:tian-deng/Cooperation.git //先不管这行 这样就算完成了. 还有一种方法就是在本地用git init命令创建, 然后回头push到Github托管服务器上就ok.\n我们要合作写项目, 那肯定要上传点东西到Github服务器, 服务器不能随便让别人直接上传到我们的项目对吧?服务器一般用的都是SSH协议来验证用户的, 所以需要先添加SSH key, 打开cmd, 在本地用ssh-keygen命令来创建公钥和密钥.一路回车就行\n然后复制id_rsa.pub的内容\n回到我们的网页, 用户头像-\u0026gt;settings-\u0026gt;ssh and gpg keys\n在这里来添加我们的公钥.\n然后就可以上传到我们的Github仓库了.\n现在, 一切前序工作都准备完成了, 我们来开始合作敲代码吧~\n合作 回到我们的Github仓库, 点击Code-\u0026gt;SSH来用SSH协议将我们的仓库拉到本地, 复制这串链接\n这里我用两个文件夹来表示我跟david. 首先bob把代码从远程复制到本地\ngit clone命令相当于把代码拷贝了一份, 就跟你直接download是一个效果.\n同样的, david也clone了一份.\n以下是bob的操作:\nbob 提交代码 bob现在想给我们的项目先增加两个功能, 一个功能是排序, 另一个功能是二分查找.\n  bob创建目录src用来放源代码.\n  bob创建文件utils.h用来规定函数签名.\n  utils.h内容如下\n#ifndef UTILS #define UTILS void sort(int[] arrays, int length); #endif   现在回到命令行工具, 我们看看仓库的创建.\n相信大部分人英语都是比我好的, 翻译过来就是\n 当前在主分支上\n主分支对比origin/master已经是最新的了\n没有跟踪的文件:\n​\tsrc/\n没有添加和提交但是存在没有跟踪的文件, 使用\u0026quot;git add\u0026quot; 来跟踪.\n 我们知道我们现在所处的分支是master, 那么这个origin/master又是个什么东西?\norigin是我们远程服务器的一个别名.我们是从Github服务器我们的仓库上克隆的代码, 所以这个origin就是git@github.com:tian-deng/Cooperation.git.\ngit remote add origin git@github.com:tian-deng/Cooperation.git 这个命令就是用来在本地和远程服务器的仓库之间建立联系的. 这样 Git push 或者说 上传 代码的时候就知道上传到哪个地方了, 解决了上面一开始的问题.\n此时查看 git log, 可以发现 origin/master 和 origin/HEAD 也存在, 意思是远程的分支和远程的最新提交在哪个地方.\n我们可以使用 git remote get-url来查看某个远程服务器别名的实际地址.\n好了继续解释 git status 的信息.\n接下来是 untracked files. 未追踪的文件就是说是我们在工作区新添加的文件, 工作区就是我们目前文件夹中的所有内容. 在他的状态还是未追踪的时候, 我们对这个 Git 仓库进行的大部分操作和命令, 都不会影响到未追踪文件, 包括但不限于git reset, git checkout, git commit, git push. 这些操作都不会对未追踪文件有任何的影响.\n未追踪文件就是个局外人, 但我们的src文件夹显然不是局外人, 所以我们使用git add命令来让它加入到我们的圈子, 加入到我们的Git仓库中.\n好了, 它不是一个局外人了. 它已经融入我们的圈子, 并且随时随地被我们监控着, 影响着.\n现在, 文件从未追踪状态进入到了暂存区, 进入到暂存区开始, 它的一言一行都会被我们观察到了. 我们现在改变utils.h的内容.\n如图, 增加了search签名. 然后再看看状态.\n我们改变文件也被追踪到了? 那么现在我想看看我改变了什么.\n使用git diff命令\n显示我们增加了 search 函数的签名.\ngit diff不加任何参数默认对比的是暂存区与工作区之间的区别(不包括未追踪文件这个局外人).\n这就是为什么会有暂存区, 暂存区极大的拓展了Git对文件追踪的能力, 它可以知道我们改变了什么, 删除了什么, 移动了什么, 而不需要在提交后才能与历史版本进行对比, 它可以追踪我们每次暂存区的变化, 相比较对版本库的diff, 对暂存区的diff属于一种更细粒度, 更精细的对比.\n如果我们想对比暂存区与版本库的区别呢?\ngit diff --cached 或者 git diff --staged\n是不是这里没有我们工作区的修改? 因为我们对工作区的修改还没添加到暂存区.\n现在我们先使用git commit进行提交.\n使用 git log 看到的是版本库的记录.\n我们可以看到除了Github帮我们初始化的提交以外, 又多了一笔新的提交, 同时, 也体现出了远程服务器上的代码还处在第一个提交的状态.\n然后我们看看仓库的状态.\n可以看到, 提示我们领先了远程服务器一个提交, 提示我们使用git push命令来上传代码. 同时还有一个工作区的修改没有添加到暂存区. 我们将其也一并提交了吧~\n现在我们领先了两笔提交了~\n然后我们使用git push origin master将我们的代码上传到origin服务器的master分支上.\n这样就上传完成了~然后我们看看我们的Github仓库.\n可以看到4min前有更新, 然后有了3笔提交.\n到这里就告一段落了~\n总之, 我们push或upload到远程服务器上的只有我们commit后的部分, 也就是说只有当前分支版本库中的东西会被上传到远程服务器中, 暂存区, 工作区都是不会被上传的.\n处理冲突 这时我突然发现我两个函数签名写错了好吧?但我又不想重新用提交来修复我这两个签名, 那么应该怎么做?\ngit reset HEAD^^ 来回退两个提交, 这就相当于同时撤销了我的commit操作和add操作, 但是不修改我们目前工作区的文件内容.\n可以看到我们回到了第一笔提交. 但是我们工作区的文件没有被回退, 在这个基础上修复一下函数签名.\n#ifndef UTILS #define UTILS void sort(int arrays[], int length); void search(int arrays[], int length); #endif 然后重新 add commit, 把之前的两笔合并到一起吧.\n然后我们上传代码.\n提示我们远程分支要比我们本地的分支领先(本地两个提交, 远程有三个, 因为我们把两笔提交合并到一起了), 提示我们要用 git pull 更新代码.\n提示我们有冲突, 需要我们处理好冲突再提交.\n那么我们再打开我们的utils.h看看.\n发现多了几行提示? \u0026lt;\u0026lt;\u0026lt;到===的部分表示我们本地的代码, ===到\u0026gt;\u0026gt;\u0026gt;的部分表示我们要merge的代码, 我们只需要保留正确的就可以了. 同时也需要删掉Git给我们的那些提示部分(\u0026lt;\u0026lt;\u0026lt;行,===行和\u0026gt;\u0026gt;\u0026gt;这三行也需要删掉).\n处理完冲突后我们重新add commit, 然后git log看看.\n我们本来只是想让提交变少一点, 现在是不是多此一举啊.\n有解决方法么? 有, 就是在git push的时候添加--force参数, 这样就完全是用本地的版本库去覆盖服务器的版本库. 这在我们自己小范围几个人做项目的时候没问题, 但是如果人多了起来, 突然发现远程版本库怎么回退了? 那中间如果夹杂了其他人的提交怎么办?他们的工作是不是也浪费掉了?\n所以一般是不会允许--force操作的, 也就是说一般是不允许回退到服务器之前的版本中的, 回退服务器中的版本是需要一定权限的. 如果自己在代码注释里骂了老板骂了公司, 没上传就晴天, 如果上传了, 就期待着老板是自己亲戚吧~\n自己的回退一般在gerrit里代码审查是无法通过的. 所以我们就带着我们的错误记录一起上传到服务器吧~\n好了, 现在bob把sort函数的实现交给david去做了, 此时david更新了代码, 快排如火如荼的进行着\u0026hellip;\u0026hellip;\n然后bob开始写search二分查找的实现(此时david在查快排是什么).\n但是二分查找法是建立在数组有序的情况下的, 所以bob就先简单实现了一个冒泡算法来应付一下排序.\n这时, bob发现他的函数签名又错了, 忘了给二分查找加一个target, 所以bob又改了改上传了\u0026hellip;然后又又又发现函数应该返回一个索引而不是void, 然后又又又改了改上传了\u0026hellip;\u0026hellip;.最后bob生气了, 直接回退到最初版本把函数签名改对, 然后--force了\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\n解放 最终utils.c文件中代码如下.\n#include \u0026#34;utils.h\u0026#34;void sort(int arrays[], int length) { for (int i = 0; i \u0026lt; length; i++) { for (int j = 0; j \u0026lt; length; j++) { if (arrays[i] \u0026lt; arrays[j]) { int temp = arrays[i]; arrays[i] = arrays[j]; arrays[j] = temp; } } } } int search(int arrays[], int length, int target) { int left = 0, right = length - 1, mid; while (left \u0026lt;= right) { mid = (left + right) / 2; if (target \u0026lt; arrays[mid]) { right = mid - 1; } else if (target \u0026gt; arrays[mid]) { left = mid + 1; } else { return mid; } } return -1; } 随后他 add commit push 三连, bob解放了\u0026hellip;\n等等\u0026hellip;bob push上传代码出问题了\n接下来是 david 在 bob 编写代码的同时所做的操作.\ndavid david明显就比bob厉害多了, 他修改代码前先创建了一个work分支.\ngit branch work, 然后使用git checkout work切换到了该分支. 然后才开始修改代码\u0026hellip;\u0026hellip;\ngit checkout -b work是这两条命令的结合版.\n对比代码 创建好分支后他好奇的看了看git log\n怎么写个接口还能有这么多提交的? bob是sb吗?\n然后他想看看为什么, 于是输入了如下命令.\n不禁默默的在头文件加了个注释.\n然后开始了他的代码之旅\u0026hellip;\u0026hellip;\n#include \u0026#34;utils.h\u0026#34;void swap(int *p, int *q) { int temp; temp = *p; *p = *q; *q = temp; } void quick_sort(int arrays[], int low, int high) { if (low \u0026gt;= high) { return; } int i = low; int j = high; int key = arrays[low]; while (low \u0026lt; high) { while (low \u0026lt; high \u0026amp;\u0026amp; key \u0026lt;= arrays[high]) --high; swap(\u0026amp;arrays[low], \u0026amp;arrays[high]); while (low \u0026lt; high \u0026amp;\u0026amp; key \u0026gt;= arrays[low]) ++low; swap(\u0026amp;arrays[low], \u0026amp;arrays[high]); } quick_sort(arrays, i, low - 1); quick_sort(arrays, low + 1, j); } void sort(int arrays[], int length) { quick_sort(arrays, 0, length - 1); } 搞定, 写完提交~\n图形化log分析分支信息 然后david切换到主分支, 开始同步到最新的代码.\n怎么回事, 一般来说同步代码后远程(origin/master和origin/HEAD)应该是最新的提交, 怎么不是最新的呢?\n我们用更清楚的git log看看情况好吧, 看看origin/master到底是怎么回事.\n --oneline :: 每个提交用一行表示, 类似于--pretty=oneline --graph :: 用图形化表示. --all :: 查看所有分支.  观察从起点到远程HEAD所在的点, 只有三笔提交.\n我们目前所在的地方, 有5笔提交.\n而我们work分支又是从ca41f1b这里开始分叉出去的.\n为什么会这么乱?为什么远程又只有三笔提交?\n原因就是bob这个sb强行进行提交, 以为可以瞒天过海.\n但实际上他所有的操作, 都是有被记录下来的. 即使使用了--force, 也是有蛛丝马迹可以查看到他的sb操作的.\n不过david宽宏大量好吧, 直接把本地主分支重制到远程服务器最新的.\ngit reset c284bca --hard\n--hard表示不仅回滚版本库与暂存库(相当于撤销了commit和add), 同时还对c284bca版本库中的文件使用git checkout -- files.....覆盖了工作区. 等于同时撤销了版本库, 暂存库, 工作区.\n然后我们回退到origin/master所在的分支看看.\n哦完美\u0026hellip;\u0026hellip;\n合并指定提交 david怎么把他的工作成果合并到主分支呢? 难道要对比着重写吗?\n正常情况下使用\ngit merge work 可以将整个work分支合并到当前分支, 也就是当前干净的主分支.这里较于简单就不细说了. 处理冲突的方法上面也有提到.\n然而此时david那边的work分支又是没有回滚前的. 我们不想使用merge把整个分支merge过来好吧, 那样的话bob的昏头操作记录岂不是又回来了.\n可不可以只挑david提交代码的那个合并过来?\n使用git cherry-pick可以指定要合并的提交, 然后只合并需要的部分就可以了.\n然后我们使用git log work --oneline就可以在不切换分支的情况下查看其他分支的log了\ngit cherry-pick 3434562\n再看看log\n完美好吧, 干净整齐.\n突然想起来, 刚才好像在一个文件里骂过bob, 怎么办呢.\ngit reset --soft HEAD^软回退到提交前, 软回退是只撤销commit, 不撤销add, 也不会把版本库或者暂存库的文件覆盖到工作区中.\n可以看到我们的暂存区也没有被回退, 省去我们重新添加utils.c文件了. 我们把那行骂bob的话删掉. 然后add commit push三连.\ngit push origin master\n工作over\nbob 同步出错 回到bob这里, 再看看错误原因.\n这里提示我们本地分支不是最新的版本, 需要先同步代码才可以. 因为david在我们提交代码前就已经把他的快排写完上传到服务器上了, 那我们同步一下试试.\n怎么又有冲突啊, bob崩溃了\u0026hellip;\n再看看状态.\n我们又有个冲突的文件src/utils.c, 这是因为david和bob都有修改文件, 合并的时候Git不知道该保留哪些部分.\n这里说明一下, git pull相当于git fetch与git merge origin/master两个操作的结合版, 输入git branch --all查看所有分支.\n可以看到包括远程的分支也在.\n也就是说git pull相当于把远程分支的代码拉下来, 然后再将它合并到当前的分支. 所以这里会提示你处理合并的冲突.\n我们之前处理过冲突这种事情, 所以再次处理冲突问题应该是小菜一碟了. 但是处理冲突会产生commit提交, 同时也会在git log --oneline --graph --all出现一个表示分支合并的横线. 我们现在想主分支只有一条干净的直线, 不要有那些弯弯绕绕, 那应该怎么做呢?\n嫁接 我们先git merge --abort撤销merge操作.\n然后使用嫁接git rebase.\ngit rebase origin/master\n同样提示我们有冲突, 那这跟git merge有什么区别吗?我们先继续向下进行.\n然后我们保留david更加高效的排序算法和bob的二分查找算法, 文件最终为这样\n#include \u0026#34;utils.h\u0026#34;void swap(int *p, int *q) { int temp; temp = *p; *p = *q; *q = temp; } void quick_sort(int arrays[], int low, int high) { if (low \u0026gt;= high) { return; } int i = low; int j = high; int key = arrays[low]; while (low \u0026lt; high) { while (low \u0026lt; high \u0026amp;\u0026amp; key \u0026lt;= arrays[high]) --high; swap(\u0026amp;arrays[low], \u0026amp;arrays[high]); while (low \u0026lt; high \u0026amp;\u0026amp; key \u0026gt;= arrays[low]) ++low; swap(\u0026amp;arrays[low], \u0026amp;arrays[high]); } quick_sort(arrays, i, low - 1); quick_sort(arrays, low + 1, j); } void sort(int arrays[], int length) { quick_sort(arrays, 0, length - 1); } int search(int arrays[], int length, int target) { int left = 0, right = length - 1, mid; while (left \u0026lt;= right) { mid = (left + right) / 2; if (target \u0026lt; arrays[mid]) { right = mid - 1; } else if (target \u0026gt; arrays[mid]) { left = mid + 1; } else { return mid; } } return -1; } 完美~\n搞定后首先git add, 然后git rebase --continue, 再来看看git log.\n是不是很干净的一条直线?并且也没有多出来任何提交~\n忽略文件 我们现在想写个函数测试一下我们的成果.\n#include \u0026lt;stdio.h\u0026gt;#include \u0026#34;utils.h\u0026#34; void print_array(int arrays[], int length) { printf(\u0026#34;[ \u0026#34;); for (int i = 0; i \u0026lt; length; i++) { printf(\u0026#34;%d \u0026#34;, arrays[i]); } printf(\u0026#34;]\\n\u0026#34;); } int main() { int a[] = {2, 3, 1, 4, 6, 0, 3, 2, 13, 64, 23, 75, 43}; sort(a, 13); print_array(a, 13); int target = 4; int index = search(a, 13, target); printf(\u0026#34;num %d\u0026#39;s index is: %d.\\n\u0026#34;, target, index + 1); } 完美~\n工作结束~\n但我们需要上传我们的main函数和编译好的二进制文件到别人那里吗?并不需要吧. 但每次git status里不停的说存在未跟踪文件, 就很烦. 怎么办呢~\n我们可以使用.gitignore文件来忽略掉我们不需要的东西, 甚至.gitignore文件本身.\n在仓库目录创建.gitignore文件\n内容如图, 目前工作结果如图.\n工作完成~\nGithub的最终成果.仓库地址\n到这里就告一段落了~你已经学会了Git的最常用的一些操作了!!!\n  ","date":"2020-09-26T21:34:18+08:00","image":"https://example.com/posts/tools/git/basic_git/cover_hu65e046bc20b3dea5f230da49649846af_19831_120x120_fill_box_smart1_2.png","permalink":"https://example.com/posts/tools/git/basic_git/","title":"Git操作指北"},{"content":"小记自己为什么会学 Rust . Rust 有什么特性吸引到我了~\n 如果说 C 语言是具备高灵活性, 信任着开发者, 将一切交给开发者来解决的话.\n那么 Rust 就是降低该灵活性, 毫不信任开发者, 将开发者的大部分错误都在编译期发掘出来, 强制要求开发者去了解可能存在的问题并解决掉它.\nC 语言可能条条大路通罗马, Rust 可能只有寥寥无几的道路.\n总之, Rust 拔高了开发者的下限, 如果水平不够是连编译器都不会通过的, 更不要说 commit 了.\n优雅的Rust 听说到 Rust 最多的自然是所谓的内存安全. 那么什么是内存安全？ 内存安全体现在哪里呢？\n比如说这段 C语言 代码.\nint a[5]; a[6] = 6; printf(\u0026#34;%d\u0026#34;, a[6]); 这段代码能正确输出 a[6] 吗?\n答案是可以的, 虽然它很明显的内存越界了, 但内存越界似乎在 C 里并不是什么大不了的事, 编写的代码随便越界, 只不过导致的后果需要自己承担而已.\n当然现今大部分的高级语言对指针越界都会有很明确的编译错误, 所以仅这点来看并不能体现出 Rust 的特点, 只不过是有了现代语言该有的东西——内存越界提示.\n那么有什么可以体现出 Rust 独有特性的地方呢?\n参考这一段结构体.\ntypedef struct { struct Node *next; int val; }Node; typedef struct { Node *head; Node *tail; int size; }LinkedList; struct { void (*push)(struct LinkedList *self, Node val); Node *(*peek)(struct LinkedList *self); Node *(*pop)(struct LinkedList *self); }StackMethod; 这是一个简单的数据结构栈, 在栈方法中定义了三个函数指针, 不需要关注 push 方法, 来看看 peek 方法.\npeek 方法将栈中的尾结点返回, 和 pop 方法的区别是它不会从链表中删除该节点. 但此时该方法的调用者拥有了该节点的所有权限, 如果调用者此时又释放了该地址指向的内存, 当再次调用 pop 方法时, pop 方法将返回一个已经释放了内存的结点指针, 此时如果访问该结点大概率会出现 Segementation fault. 因为访问了一个没有分配的内存空间. Segementation fault 大概是我写 C 时候最讨厌的错误了.\n那么 Rust 是如何解决的呢? 答案是所有权.\n所有权 fn main(){lets1=String::from(\u0026#34;hello\u0026#34;);lets2=s1;}在将 s1 赋值给 s2 后, 此时 s1 就已经是无效的了, 它的作用域仅到赋值给 s2 之前为止.\n同样类似的.\nfn hello(str: String){println!(\u0026#34;{}\u0026#34;,str);}fn main(){lets1=\u0026#34;hello\u0026#34;.to_string();hello(s1);println!(\u0026#34;{}\u0026#34;,s1);// error }这段相等同的 C 代码会有问题么?\n可能会有问题. 如果在 hello 中释放了内存, 那么 main 函数中后续对 s1 的访问就会出现段错误. 就像这样:\nvoid hello(char* str) { printf(\u0026#34;%s\\n\u0026#34;, str); free(str); } int main() { char s1[5] = { \u0026#39;h\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;}; hello(s1); printf(\u0026#34;%s\\n\u0026#34;, s1); } 在 Rust 中就完全避免了这种情况, 这样的代码在Rust中连编译都不会通过的.\n那么 main 函数后续不能再用该变量了吗? 有两种方法可以解决该问题.\n可以将 hello 函数的签名增加个返回值, 使用完变量后将其所有权返回给调用者. main 函数也需要提供一个接收者接收该变量的所有, 该做法使用了 Rust 变量覆盖的特性, 可以声明同名变量, 就跟 Javascript 类似. 后续声明的同名变量会覆盖先前的.\nfn hello(str: String)-\u0026gt;String {println(\u0026#34;{}\u0026#34;,str);str}fn main(){lets1=\u0026#34;hello\u0026#34;.to_string();lets1=hello(s1);println!(\u0026#34;{}\u0026#34;,s1);}第一种是个很自然而且很容易想到并理解的做法( Rust 中函数块最后一行且没有带分号的会被当做返回值, 所以可以省略掉 return ). 还有另一种做法, 那就是引用.\nfn hello(str: \u0026amp;String){println!(\u0026#34;{}\u0026#34;,*str);}fn main(){lets1=\u0026#34;hello\u0026#34;.to_string();hello(\u0026amp;s1);println!(\u0026#34;{}\u0026#34;,s1);}使用 \u0026amp; 表示一个引用或引用类型, * 则表现为消除 \u0026amp;, 也就是解引用. 用法类似与 C 中的指针. 而在 Rust 中是会自动解引用的, 所以 hello 函数也可以改为:\nfn hello(str: \u0026amp;String){println!(\u0026#34;{}\u0026#34;,str);}在 C 中可能存在的野指针问题在 Rust 中也可以通过所有权系统来解决.\n 野指针主要为未初始化或释放后未置空或操作超越变量作用域.\n 参照如下 C 代码:\n#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;stdlib.h\u0026gt;int main(void) { int *p = (int *)malloc(4); *p = 4; free(p); int *q = (int *)malloc(4); *q = 2; printf(\u0026#34;q = %d\\n\u0026#34;, *q); //此处打印 q = 2  *p = 4; printf(\u0026#34;q = %d\\n\u0026#34;, *q); //此处打印 q = 4 } 是不是很神奇. 那么为什么会出现这种现象?\n因为在 C 中使用 malloc 分配内存的时候, 会优先分配前次释放的内存, 所以两处调用 malloc 所得到的地址是一样的. 在释放 p 之后, 没有对 p 进行赋空操作, 此时 p 就成了一个野指针. 然后接着又分配了一个跟前序 p 一样大小的内存空间, 此时 p 和 q 就是一样的了——指向相同的地址. 所以对 p 指向的值进行的修改会反映在 q 上. 虽然简单的在释放 p 后给其赋值为 NULL 就可以了, 但是如果有个人疏忽了呢? 毕竟人是不会永远不犯错的. 在 Rust 中类似这样的代码是不可能通过的, 因为在释放 p 的时候所有权已经转移给 free 函数了, main函数后续是不能再使用的.\n不管是学过 Java 的还是学过 C 的, 肯定都多多少少了解过关于引用传递和值传递, 有相当多的教学声明 Java 中仅存在值传递.\n在 C 语言中指针则类似于引用传递, 通过地址引用指向内存空间的值. 因为有地址所以可以修改其中的值并且被其它函数观察到. 传递引用有一个问题, 有时候我们并不想别人改变我们的值, 但又不得不声明为指针(比如说结构体的自引用), 同时又忘了给该参数声明为 const , 这样就会有很多问题. 尤其在初学 C 的时候, 几乎很少有人会用到 const 关键词. 很多人是不晓得该关键词到底有多么重要的, 而 Rust 就会强迫我们去学习, 了解不可变的重要性.\n那么很自然的就过渡到下一个阶段~\n可变性与不可变性 然而在 Rust 中所有的变量如果不显式声明, 那就是不可修改的( unsafe 是特例). 所以如果要传递一个可变引用, 就需要如下的声明:\nfn hello(str: \u0026amp;mutString){println!(\u0026#34;{}\u0026#34;,str);str.push_str(\u0026#34;world\u0026#34;);//3. 修改str的值. }fn main(){letmuts1=\u0026#34;hello\u0026#34;.to_string();//1. 此处声明s1是可变的变量. hello(\u0026amp;muts1);//2. 传递一个可变引用给hello函数. println!(\u0026#34;{}\u0026#34;,s1);}显式声明 str 是可变的, 否则对变量做的任何修改在编译期都是无法通过的. 这就避免了很多 Code 时的隐性错误.\nRust 中关于该特性有几个关键点.\n 变量可以有多个不可变引用. 变量只能有一个可变引用. 变量有可变引用的同时不能有不可变引用.  比如如下代码:\nfn main(){letmuts1=\u0026#34;hello\u0026#34;.to_string();lets2=\u0026amp;s1;hello(\u0026amp;muts1);println!(\u0026#34;{}\u0026#34;,s1);println!(\u0026#34;{}\u0026#34;,s2);}编译时会报错\n error[E0502]: cannot borrow s1 as mutable because it is also borrowed as immutable\n 错误提示相当友好了, 不能将 s1 作为可变引用因为它已经有一个不可变引用了. 为什么要这么设计?\n可以想象一下在 C 中, 编写了一个返回指针的函数, 有多个不同调用方或许都对指向的值进行了修改, 某个调用方又如何知道该值是否是最初的函数所返回的呢? 还是因为各个调用方可能进行的修改后的结果. 解决方法肯定是有的, 比如说注意一下各个调用方的顺序之类的, 只是有时项目庞大而复杂, 是没法顾及到方方面面, 这时是需要有个 \u0026ldquo;人\u0026rdquo; 来提醒一下我们.\n因此, 可变引用与不可变引用直接是互斥的, 不可变引用之间也是互斥的, 它们不能同时存在.\n上面的代码调换一下位置就可以了.\nfn main(){letmuts1=\u0026#34;hello\u0026#34;.to_string();hello(\u0026amp;muts1);lets2=\u0026amp;s1;println!(\u0026#34;{}\u0026#34;,s1);println!(\u0026#34;{}\u0026#34;,s2);}此时在 s2 声明的位置, s1 的可变引用的作用域已经结束, 现在 s1 是没有其它引用的, 所以可以拿到其的一个引用.\n 在这里, 为了引入个下一话题, 我们不自然地回顾一下上一章节的野指针问题~\n类似的如下 C 代码:\n#include \u0026lt;stdio.h\u0026gt;char *dangle() { char a[3] = \u0026#34;abc\u0026#34;; printf(\u0026#34;%s\\n\u0026#34;, a); return a; } int main(void) { char *p = dangle(); printf(\u0026#34;%s\\n\u0026#34;, p); } 在函数结束的时候变量 a 已经被销毁, 将该地址返回就会产生野指针.\n如何修正该代码?\n#include \u0026lt;stdio.h\u0026gt;char *dangle() { char *a = \u0026#34;abc\u0026#34;; printf(\u0026#34;%s\\n\u0026#34;, a); return a; } int main(void) { char *p = dangle(); printf(\u0026#34;%s\\n\u0026#34;, p); } 这样就可以了.这样所声明的变量 a 实际上为字符串常量, 是不可变的, 存储在静态存储区. 由程序结束后操作系统回收该部分内存. 所以在函数结束后 a 指向的值是不会被销毁的. 将该地址返回也是完全没有错误的.\n这些细枝末节在初学 C 的时候是很难注意到的. 毕竟大多数大学生使用的教材还是谭浩强版, 用于应试是够了, 实际开发是远远不行的.\n如果在 Rust 中写出这样的代码呢?\nfn main(){letreference_to_nothing=dangle();}fn dangle()-\u0026gt; \u0026amp;String {lets=String::from(\u0026#34;hello\u0026#34;);\u0026amp;s}首先说点题外话, 在 Rust 中命名通常用蛇形命名法, 不像 Java 中普遍的是大驼峰和小驼峰. 至于好看与否, 看眼缘吧~\n这里同样的编译是不能通过的.\n error[E0106]: missing lifetime specifier \u0026ndash;\u0026gt; src\\main.rs:5:16 | 5 | fn dangle() -\u0026gt; \u0026amp;String { | ^ expected named lifetime parameter | = help: this function\u0026rsquo;s return type contains a borrowed value, but there is no value for it to be borrowed from help: consider using the 'static lifetime | 5 | fn dangle() -\u0026gt; \u0026amp;\u0026lsquo;static String { | ^^^^^^^^\n 可以说相当友好了, 编译器同时提示了错误是什么, 以及该如何解决它.\n该错误说明了该函数缺少生命周期指示符. 帮助说明了该函数返回的值包含了一个引用值, 但是这种类型是没有可以用来借用的, 需要考虑加上 'static 生命周期, 这样就杜绝了返回局部变量引用的情况.\n这样就引入了下一个话题~\n生命周期 以下内容主要参考 The Rust Programming Language\n生命周期只是一个标签, 语法是'+字符串/字符. 比如 'a, 'b. 'static 是一个特殊的生命周期, 表示静态存储, 类似于 Java 和 C\\C++ 中的 static, 也就是一直存活到程序结束运行才会销毁.\n生命周期主要是为了避免悬垂引用(野指针), 在 Rust编译器 中实现了一个借用检查器, 通过比较作用域来确保所有借用的有效性.\n{letr;// ---------+-- \u0026#39;a {// | letx=5;// -+-- \u0026#39;b | r=\u0026amp;x;// | | }// -+ | println!(\u0026#34;r: {}\u0026#34;,r);// | }// ---------+ 这里 r 的生命周期为 'a, x 的生命周期为 'b , 'b 的范围小于 'a 的范围, 由于 r 引用了一个存活范围小于它的变量, 所以会编译失败.\n{letx=5;// ----------+-- \u0026#39;b letr=\u0026amp;x;// --+-- \u0026#39;a | println!(\u0026#34;r: {}\u0026#34;,r);// | | // --+ | }// ----------+ 改为这样子, 因为 r 的生命周期 'a 小于 'b , 这样就能保证在 r 有效的时候 x 总是有效的, 这样 r 就不可能变成一个野指针.\n考虑这样一个函数:\nfn longest(x: \u0026amp;str,y: \u0026amp;str)-\u0026gt; \u0026amp;str {ifx.len()\u0026gt;y.len(){x}else{y}}fn main(){letstring1=String::from(\u0026#34;long string is long\u0026#34;);{letstring2=String::from(\u0026#34;xyz\u0026#34;);letresult=longest(string1.as_str(),string2.as_str());println!(\u0026#34;The longest string is {}\u0026#34;,result);}}乍看之下没有什么问题对吧? 但是编译还是不通过.\n error[E0106]: missing lifetime specifier \u0026ndash;\u0026gt; src\\main.rs:1:33 | 1 | fn longest(x: \u0026amp;str, y: \u0026amp;str) -\u0026gt; \u0026amp;str { | \u0026mdash;- \u0026mdash;- ^ expected named lifetime parameter | = help: this function\u0026rsquo;s return type contains a borrowed value, but the signature does not say whether it is borrowed from x or y help: consider introducing a named lifetime parameter | 1 | fn longest\u0026lt;\u0026lsquo;a\u0026gt;(x: \u0026amp;\u0026lsquo;a str, y: \u0026amp;\u0026lsquo;a str) -\u0026gt; \u0026amp;\u0026lsquo;a str { | ^^^^ ^^^^^^^ ^^^^^^^ ^^^\n 根据报错提示, 我们修改函数签名为fn longest\u0026lt;'a\u0026gt;(x: \u0026amp;'a str, y: \u0026amp;'a str) -\u0026gt; \u0026amp;'a str 这样这段代码就可以正确运行了. 生命周期在函数签名中的用法类似于泛型, 前面多个单引号而已. 然后在对应的参数上声明所需要的生命周期就可以了.\n这个函数签名表示告诉调用者 x , y , str 这三个至少能存活的一样久, 否则就不能编译通过.\n我们修改下 main 函数为如下:\nfn main(){letstring1=String::from(\u0026#34;long string is long\u0026#34;);letresult;{letstring2=String::from(\u0026#34;xyz\u0026#34;);result=longest(string1.as_str(),string2.as_str());}println!(\u0026#34;The longest string is {}\u0026#34;,result);}我们将延长 result 的生命周期, 并且将 println 移动到块外面, 这样子编译是不通过的. 来看看编译错误信息:\n error[E0597]: string2 does not live long enough \u0026ndash;\u0026gt; src\\main.rs:14:44 | 14 | result = longest(string1.as_str(), string2.as_str()); | ^^^^^^^ borrowed value does not live long enough 15 | } | - string2 dropped here while still borrowed 16 | println!(\u0026ldquo;The longest string is {}\u0026rdquo;, result); | \u0026mdash;\u0026mdash; borrow later used here\n 提示我们 string2 在 println 前就被释放了. 如果像之前那样没有给函数签名加上生命周期的话, 编译器是不能知道函数返回的值到底能存活多久的, 生命周期表明了返回的值与参数的生命周期应该是一致的, 这里所谓的一致是指同样生命周期标签中最小的那个. 在正确的代码中, 三个参数分别对应的 string1, string2, result 中, 最短的那个是 result , 编译器能推断出在 result 存活的范围它所引用的值是一直有效的.\n而在错误的代码中, string2 是生命周期最短的那个, 所以编译器推断出 result 只能在 string2 存活的范围内使用, 一旦超出该范围, 就可以提示调用者需要修改代码.\n简单说下 Rust 如何清理内存, 只要让它离开作用域就可以了, 离开作用域的时候会自动调用该类型的 drop 方法, 而 drop 一般都是由编译器提供默认实现的, 有时候默认实现不够高效才需要自己去实现. 我们不能调用变量的 drop 方法, 那样就会有多次释放的问题, 如有需要可以调用标准库提供的 drop 函数.\n标准库有提供一个 drop 函数, 用来手动释放内存, 可以看看它的实现~\n core::mem pub fn drop(_x: T) Disposes of a value. This does so by calling the argument\u0026rsquo;s implementation of Drop. This effectively does nothing for types which implement Copy, e.g. integers. Such values are copied and then moved into the function, so the value persists after this function call. This function is not magic; it is literally defined as pub fn drop(_x: T) { }\nBecause _x is moved into the function, it is automatically dropped before the function returns.\n 它的实现仅仅是一个空函数块, 将该变量的所有权转移到该函数块中, 在结束的时候调用该变量的 drop 方法.\n 上面似乎都是一些内存安全相关的特性, 感觉只体现出来 Rust 编译器的强大, 接下来, 可以转下一个话题了, 简单介绍下 Rust 的一些优雅的语法特性~\nTrait Trait 类似与 Java 中的接口概念, 近年来一直以来都有组合大于继承的口号, Trait 就是在 Rust 中用来实现组合这一理念的.\n继承有时候用起来是真的不顺心. 继承吧, 好多用不到的东西, 不继承吧, 又有很多重复工作要做. Rust 中干脆扔掉了继承.\n像前面讲到的实现 drop 方法, 怎么为我们的类型实现 drop 方法呢?\nDrop 中只有一个方法, 它的签名为: fn drop(\u0026amp;mut self); 所以我们就像实现接口一样实现该方法就可以了.\nstruct MyVar{names: Vec\u0026lt;String\u0026gt;}implDropforMyVar{fn drop(\u0026amp;mutself){\u0026amp;self.names;println!(\u0026#34;MyVar drops\u0026#34;);}}fn main(){let_=MyVar{names: vec![\u0026#34;hello\u0026#34;.to_string(),\u0026#34;world\u0026#34;.to_string()]};}运行后将打印出 MyVar drops , 可以看出来在离开作用域后就自动调用了我们自定义的 drop 方法.\n可以用 Trait 配合泛型编写一个通用的 largest 函数.\nfn largest\u0026lt;T: PartialOrd +Clone\u0026gt;(list: \u0026amp;[T])-\u0026gt; T{letmutlargest=list[0].clone();foriteminlist.iter(){if*item\u0026gt;largest{largest=item.clone();}}largest}fn main(){letnumber_list=vec![34,50,25,100,65];letresult=largest(\u0026amp;number_list);println!(\u0026#34;The largest number is {}\u0026#34;,result);letchar_list=vec![\u0026#39;y\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;q\u0026#39;];letresult=largest(\u0026amp;char_list);println!(\u0026#34;The largest char is {}\u0026#34;,result);}PartialOrd 是基于排序为目的而比较一个类型, 实现了该 Trait 的类型就可以使用 \u0026gt; , \u0026lt;= , \u0026gt; , \u0026gt;= , 可以近似的看作 C++ 中的操作符重载.\n这里再简单说明一下 Copy 和 Clone.\nClone 就是所谓的 深拷贝 , 我们也可以用 Copy , Copy 是浅拷贝.\nCopy 是简单的拷贝存储再栈上的位来赋值值, 比较高效, 是一个标记型 Trait , 该 Trait 的实现基准是: 如果一个类型内部的类型全部是 Copy 的, 那么该类型也是 Copy , 比如所有的基本类型. 而 Clone 是深拷贝, 我们需要为必要的类型自己实现该 Trait , 当调用一个 Clone 的时候我们应该知道该操作可能会比较慢.\n我们也可以为 Triat 实现 Trait , 这用到了 Rust 中的动态分发, 这里不详细说明, 只做介绍.\ntraitAnimal{fn name(\u0026amp;self)-\u0026gt; String;}traitBark{fn bark(\u0026amp;self);}struct Dog;implAnimalforDog{fn name(\u0026amp;self)-\u0026gt; String {\u0026#34;Kitty\u0026#34;.to_string()}}implBarkforBox\u0026lt;dynAnimal\u0026gt;{fn bark(\u0026amp;self){println!(\u0026#34;{} bark.\u0026#34;,self.name());}}fn main(){letdog: Box\u0026lt;dynAnimal\u0026gt;=Box::new(Dog);dog.bark();}我们可以用 Trait 来组合成我们最终所需要的类型, 每个 Trait 都是那么的小巧简洁~ 不像是继承, 继承有着严重的耦合, 并且显得不是那么精巧.\n 之前我们有提到过 Rust 中是没有空指针的, 那么我们如何表示一个可能存在的值呢?\n如果有人用过 JDK8 中的 Optional 的话, 那应该就很熟悉了~答案就是 Option.\nOptional 在 Java 中出现的太晚了, 很多人对这个特性是不怎么了解的, 迁移起来也很麻烦, 普遍还是使用空指针和捕获空指针异常来处理.\n而在 Rust 中 Option 遍布了各个角落, Option 只是一个简单的枚举, 所以我们直接说明下 Rust 中使用枚举处理空指针和异常错误的方法.\n枚举 Option Option 只是一个简单的枚举类型, 但是在 Rust 中枚举是很强大的.\nOption 的签名是\npubenum Option\u0026lt;T\u0026gt;{None,Some(T),}它是这么使用的:\nfn main(){letx=Option::Some(1);matchx{Some(x)=\u0026gt;println!(\u0026#34;Val is: {}\u0026#34;,x),None=\u0026gt;println!(\u0026#34;No val\u0026#34;)};}在 Rust 中对于枚举的所有类型都强制遍历处理, 当然也可以用 _ 来忽略掉不需要的部分, 所有我们不确定是否有值的地方都需要用 Option 来表示.\nResult Rust 中也是用枚举来处理异常错误.\nusestd::net::TcpStream;fn main(){lettcp_stream=TcpStream::connect(\u0026#34;127.0.0.1:8000\u0026#34;);matchtcp_stream{Ok(_)=\u0026gt;println!(\u0026#34;success\u0026#34;),Err(e)=\u0026gt;println!(\u0026#34;{}\u0026#34;,e),};}不需要捕获异常, 要知道 Java 中捕获异常是很耗费性能的, 使用枚举来处理空指针和异常错误是不是很优雅~\n除了使用模式匹配外, 我们还可以使用 if let , 如下:\nusestd::net::TcpStream;fn main(){lettcp_stream=TcpStream::connect(\u0026#34;127.0.0.1:8000\u0026#34;);ifletOk(_)=tcp_stream{println!(\u0026#34;success\u0026#34;);}else{println!(\u0026#34;error\u0026#34;);}}同样类似的还有 while let .\nSummary 上述差不多说明了一些为什么我选择学 Rust 的理由, 当然还有很多其它的, 我所述并不足以解释 Rust 在最受程序员欢迎的语言调查中占据榜一.\n我在写 C 代码的时候, 总会纠结该不该释放内存, 有没有野指针的可能. 也烦恼与标准库不够好用, 各平台头文件不够统一, 没法编写多平台通用的代码.\n同样的, 在写 Java 的时候又会感觉有些啰嗦, 很多写法不够简洁.\n而 Rust 的话, 标准库足够好用, 是否内存安全有编译器提醒, 而且写起来有很多语法糖比 Java 要小巧很多, 也只有很小的运行时, 没有垃圾回收, 可以直接打包成二进制文件运行. 性能与 C 是差不多的.\n不过说来我学 Rust 还有一个原因是因为它够难, 而且没什么历史包袱, 比较有挑战. C++ 的历史包袱换个词也可以说是经验积累, 不过我个人觉得有些太过厚重, 有些难啃吧.\n本文浅尝辄止, 简单说明了一些 Rust 的特性. 这些特性差不多都是众多程序员在编写 C/C++ 程序中总结出来的类似于最佳实践之类的东西. 所以本文也大量对比了 Rust 和 C , 并且学习 Rust 也是离不开 C 的, 其中存在了 unsafe 这样的东西. 不了解 C 的话是没法写 unsafe 部分的, 当然这部分大部分程序员也不怎么会接触到.\n同时 Rust 作为系统级语言, 与 C 也有着非常友好的交互性, 很容易使用的 FFI , 不管是为了从 C 逐步切换到 Rust , 还是为了牺牲点安全提高灵活性的目的而使用 FFI , 这都算是一个亮点了. 毕竟 C 在各个领域都算是不可或缺的基本编程语言了.\n","date":"2020-09-15T15:30:44+08:00","image":"https://example.com/posts/rust/elegent_rust/cover_hu99bb65b34be40363fd484c863e327c7b_227902_120x120_fill_box_smart1_2.png","permalink":"https://example.com/posts/rust/elegent_rust/","title":"优雅的Rust"}]